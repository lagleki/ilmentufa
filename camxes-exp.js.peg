// This is a Parsing Expression Grammar for Lojban.
// See http://bford.info/packrat/
// 
// All rules have the form:
// 
//     name = peg_expression
// 
// which means that the grammatical construct "name" is parsed using
// "peg_expression".  
// 
// 1)  Names in lower case are grammatical constructs.
// 2)  Names in UPPER CASE are selma'o (lexeme) names, and are terminals.
// 3)  Concatenation is expressed by juxtaposition with no operator symbol.
// 4)  / represents *ORDERED* alternation (choice).  If the first
//     option succeeds, the others will never be checked.
// 5)  ? indicates that the element to the left is optional.
// 6)  * represents optional repetition of the construct to the left.
// 7)  + represents one_or_more repetition of the construct to the left.
// 8)  () serves to indicate the grouping of the other operators.
//
// Longest match wins.

// How to compile using Node.js: (Added by Masato Hagiwara)

// // load peg.js and the file system module
// > var PEG = require("pegjs")
// > var fs = require("fs")
// // read peg and build a parser
// > var camxes_peg = fs.readFileSync("/path/to/camxes.js.peg").toString();
// > var camxes = PEG.buildParser(camxes_peg, {cache: true});
// // test it
// > camxes.parse("ko'a broda");
// [ 'text',
//   [ 'text_1',
//     [ 'paragraphs', [Object] ] ] ]
// // write to a file
// > fs.writeFileSync("/path/to/camxes.js", camxes.toSource());


// ___ GRAMMAR ___

{
  var _fa_letters = {a: 1, e: 2, i: 3, o: 4, u: 5};
  var _letter_fa = Object.keys(_fa_letters).reduce(function (a,b) { a[_fa_letters[b]] = b; return a }, {});
  var _se_cmavo = {se: [0, 1], te: [0, 2], ve: [0, 3], xe: [0, 4]};
  var _cktj_names = /cykytyjy|creka(tanru(djacu)?)?bu|cektau(jau)?bu|cetki(tau(jau)?)?bu/;
  var _stressed_vowels = {a: "à", e: "è", i: "ì", o: "ò", u: "ù"};
  var _g_zoi_delim, _g_fuhe = 0;
  
  function _join(arg)
  {
    if (typeof(arg) == "string")
      return arg;
    else
    {
      var ret = "";
      for (var v in arg) { ret += _join(arg[v]); }
      return ret;
    }
  }
  
  function _word(selmaho, word) {
    return {selmaho: selmaho, word: _join(word)};
  }
  
  function _brivla(word) {
    if (Array.isArray(word))
      return {selmaho: "BRIVLA", word: options.k && word.join("/") || _join(word), rafsi: word};
    else
      return {selmaho: "BRIVLA", word: _join(word)};
  }
  
  function _quote(word, quote) {
    word = _duplicate_less_evil(word);
    word.quote = quote;
    word.single_word = word.word;
    if (options.text)
      word.word = word.word + " " + (quote.word || quote);
    else
      word.word = "[" + word.word + " " + (quote.word || quote).replace(/[\][{}()<>]/g, "") + "]";
    return word;
  }
  
  function _elided(selmaho) {
    return {selmaho: selmaho, word: selmaho.toLowerCase().replace(/h/g, "'"), elided: true};
  }
  
  function _amalgam(word, text) {
//    if (!word.amalgam)
//      word.amalgam = [word.word];
//    else
//      word.amalgam.push(word.word);
//    word.word = text;
    word.structure = text;
    return word;
  }
  
  function _bracket(array) {
    if (Array.isArray(array)) {
      array = array.filter(_empty);
      if (array.length == 1) return _bracket(array[0]);
      else if (options.format == "text") return array.map(_bracket).join(" ");
      else return "[" + array.map(_bracket).join(" ") + "]";
    }
    
    if (typeof array == "object" && array.structure)
      return _bracket(array.structure);
    
    if (typeof array == "object" && array.word)
      return _bracket(array.elided ? array.word.toUpperCase() : array.word);
    
    if (typeof array == "string")
      return array;
      
    return "[???]";
  }
  
  function _word_pre(word, pre) {
    word = _duplicate_less_evil(word);
    if (pre) {
      if (pre[0] && pre[0].length)
        word.pre = pre[0];
      if (_empty(pre[1]))
        word.word = pre[1] + word.word;
    }
    return word;
  }
  function _word_post(word, post, sa) {
    if (post) word.post = post;
      
    if (post && post.indicators)
      _amalgam(word, [word.pre, _shell(word), post.indicators].filter(_empty));
    else
      _amalgam(word, [word.pre, _shell(word)].filter(_empty));
      
    if (_empty(sa)) word.sa = sa;
    return word;
  }
  
  function _shell(word) {
    var ret = {};
    if (word.structure) ret.structure = word.structure;
    else if (word.word) ret.word = word.word;
    if (word.selmaho) ret.selmaho = word.selmaho;
    if (word.elided) ret.elided = word.elided;
    return ret;
  }
  
  function _empty(array) {
    return array && (!Array.isArray(array) || array.length) && array;
  }
  
  function _tanru(seltau, tertau, co, bo) {
    var tanru = {seltau: seltau, tertau: tertau};
    if (co) {
      tanru.co = co;
      tanru.structure = [tertau, co, seltau];
    } else if (bo) {
      tanru.bo = bo;
      tanru.structure = [seltau, bo, tertau];
    } else {
      tanru.structure = [seltau, tertau];
    }
    return tanru;
  }
  
  function _fill_jek(left, jek, right, bo_tag, bo, pehe) {
    jek = {jek: jek || _fake_jek("ju'e")};
    jek.left = left;
    jek.right = right;
    jek.structure = pehe ? [left, pehe, jek.jek] : [left, jek.jek];
    if (bo_tag) jek.structure.push(jek.bo_tag = bo_tag);
    if (bo) jek.structure.push(jek.bo = bo);
    jek.structure.push(right);
    return jek;
  }
  
  function _fill_gek(gek, left, gik, right) {
    gek = {gek: gek};
    gek.left = left;
    gek.right = right;
    gek.gik = gik;
    gek.structure = [gek.gek, left, gik, right];
    return gek;
  }
  
  function _fill_free(clause, free, name) {
    if (!_empty(free)) return clause;
    if (!name) name = "free"
    
    if (clause[name]) {
      clause[name] = clause[name].concat(free);
      clause.free_concat = (clause.free_concat || 0) + 1;
    } else {
      clause[name] = free;
      if (name == "free") {
        clause.structure = [_shell(clause), free];
      }
    }
    return clause;
  }
  
  function _term(tag, sumti, inverted, ku) {
    var term = {tag: tag};
    if (sumti) {
      if (sumti.selmaho == "KU")
        term.terminator = sumti;
      else
        term.sumti = sumti;
    }
    if (inverted) {
      term.inverted = inverted;
      term.structure = [sumti, inverted, tag, ku];
    } else {
      term.structure = [tag, sumti];
    }
    return term;
  }
   
  function _sumti_five(quantifier, sumti, relative) {
    if (!quantifier && !relative) return sumti;
    return {
      role: "sumti_5",
      quantifier: quantifier,
      sumti: sumti,
      relative: relative,
      structure: [quantifier, sumti, relative],
    };
  }
  
  function _relativized_selbri(selbri, relative, outer_relative, quantifier) {
    return {
      role: "relativized_selbri",
      selbri: selbri,
      relative: relative,
      outer_relative: outer_relative,
      quantifier: quantifier,
      structure: [quantifier, selbri, relative].filter(_empty),
    };
  }
  
  function _fake_jek(word) {
    return {
      structure: [{word: word || "je", selmaho: "JOI", elided: true}],
      elided: true,
    };
  }
  
  function _duplicate_evil(thing) { // FIXME this murders kittens
    return JSON.parse(JSON.stringify(thing));
  }
  
  function _duplicate_less_evil(thing) {
    var clone = {};
    Object.keys(thing).forEach(function (a) { clone[a] = thing[a] });
    return clone;
  }
  
  function _count_fa(terms, last, used, forgetful) {
    if (!last) last = 1;
    if (!used) used = {};
    function count_single(term) {
      if (!term.tag) {
        if (term.termset) {
          var ret = _count_fa(term.terms, last, used, term.quantifier);
          if (!term.quantifier) {
            last = ret.last;
            used = ret.used;
          }
          return !ret.abandoned;
        }
        if (term.left && term.right) {
          var left = _count_fa(term.left.terms || [term.left], last, _duplicate_evil(used));
          var right = _count_fa(term.right.terms || [term.right], last, _duplicate_evil(used));
          if (left.abandoned || right.abandoned || left.last != right.last || JSON.stringify(left.used) != JSON.stringify(right.used)) {
            //console.log("abandoned! " + JSON.stringify(left) + JSON.stringify(right))
            return false;
          } else {
            //console.log("NOT abandoned! " + JSON.stringify(left) + JSON.stringify(right))
            last = right.last;
            used = right.used;
          }
        }
        return true;
      }
      term = term.tag;
      if (term.last_fa) last = term.last_fa;
      var has_tagged = term.tagged_fa && term.tagged_fa.length;
      if (has_tagged) {
        term.tagged_fa.forEach(function (num) {
          used[num] = true;
        });
        term.fa = term.tagged_fa;
        if (!forgetful)
          while (++last in used);
      }
      if (term.implicit_fa) {
        term.implicit_fa = last;
        used[last] = true;
        if (has_tagged)
          term.fa = term.tagged_fa.concat(last);
        else
          term.fa = [last];
        if (term.tags && term.tags[0]) {
          var /*hoisting!*/ fa_word = "f" + (_letter_fa[last] || "axi" + last + term.boi);
          term.tags[0].word = fa_word;
        }
        if (!forgetful)
          while (++last in used);
      }
      return true;
    }
    var abandon = !terms.every(count_single);
    if (forgetful && last in used)
      while (++last in used);
    return {last: last, used: used, abandoned: abandon};
  }
  
  function _count_fa_tail(tail, last, used) {
    if (tail == null) return null;
    if (tail.contents) tail = tail.contents;
    var tails = tail.tails || (tail.left && tail.right ? [tail.left, tail.right] : null);
    if (tails) {
      var counts = tails.map(function (tail) { return _count_fa_tail(tail, last, _duplicate_less_evil(used)) });
      if (counts.some(function (tail, i, a) {
            return tail.abandoned
              || i > 0 && tail.last != a[i - 1].last
              || i > 0 && JSON.stringify(tail.used) != JSON.stringify(a[i - 1].used) 
          })) {
        //console.log("gihek abandoned! " + JSON.stringify(left) + JSON.stringify(right))
        return false;
      } else {
        //console.log("gihek NOT abandoned! " + JSON.stringify(left) + JSON.stringify(right))
        last = counts[tails.length - 1].last;
        used = counts[tails.length - 1].used;
      }
    } else {
      if (tail.tail) {
        var fa_after_head = tail.head && _count_fa(tail.head.terms, last, used) || {};
        return _count_fa_tail(tail.tail, fa_after_head.last || 1, fa_after_head.used || {});
      }
      var preterms = {last: last, used: used};
      if (tail.preterms) {
        tail.preterms.every(function (a) {
          preterms = _count_fa(a.terms, preterms.last, preterms.used);
          return !preterms.abandoned;
        });
      }
      if (preterms.abandoned) return preterms;
      used = preterms.used;
      last = 1; while (++last in used);
    }
    if (tail.tail_terms && tail.tail_terms.terms) {
      if (tail.selbri && tail.selbri.co) {
        var /* hoisting */ postterms = _count_fa(tail.tail_terms.terms.terms, 2, {});
        if (postterms.abandoned) {
          preterms.abandoned = true;
          return preterms;
        }
        return {
          used: Object.keys(postterms.used).reduce(function (a, b) {
              if (postterms[b])
                a[b] = postterms[b];
              return a;
            }, _duplicate_less_evil(preterms.used)),
          last: Math.max(preterms.last, postterms.last),
          coleft: preterms,
          coright: postterms,
        };
      }
      preterms = _count_fa(tail.tail_terms.terms.terms, last, used);
    }
    return preterms;
  }
  
  function _precedence(ke, contents, kehe) {
    return {role: "precedence", ke: ke, contents: contents, kehe: kehe, structure: [ke, contents, kehe]};
  }
  
  function _place_shell(unit) {
    unit = _duplicate_less_evil(unit);
    if (!unit.se_table) {
      unit.se_table = [1, 2, 3, 4, 5];
      unit.next_se = 6;
    }
    unit.place = function (outer) {
      return [_bracket(unit), this.se_table && this.se_table.length >= outer 
                              ? this.se_table[outer] : outer + 1];
    };
    return unit;
  }
  
  function _place_se(se, unit) {
    if (Array.isArray(unit))
      unit = {structure: unit};
    unit = _duplicate_less_evil(unit);
    unit.structure = [se, _shell(unit)];
    
    if (unit.se) unit.se = unit.se.concat(se);
    else unit.se = [se];
    
    if (unit.se_table) {
      unit.se_table = _duplicate_evil(unit.se_table);
    } else {
      unit.se_table = [1, 2, 3, 4, 5];
      unit.next_se = 6;
    }
    
    if (se.word in _se_cmavo) {
      // hoist!
      var places = _se_cmavo[se.word];
      var max = Math.max.apply(null, places);
      while (unit.se_table.length <= max)
        unit.se_table.push(unit.next_se++);
      var temp = unit.se_table[places[0]];
      unit.se_table[places[0]] = unit.se_table[places[1]];
      unit.se_table[places[1]] = temp;
    }
    return unit;
  }
  
  function _linkargs_attach(linkargs, unit) {
    linkargs = _duplicate_less_evil(linkargs);
    linkargs.selbri = unit;
    linkargs.structure = linkargs.inverted ? [_shell(linkargs), unit]
      : [unit, _shell(linkargs)];
    if (unit.se_table) {
      linkargs.se_table = _duplicate_evil(unit.se_table);
      linkargs.next_se = unit.next_se;
      var max = Math.max.apply(null, Object.keys(linkargs.count.used));
      while (linkargs.se_table.length < max)
        linkargs.se_table.push(linkargs.next_se++);
      linkargs.se_table = linkargs.se_table.filter(function (e, i) {
        return !(i + 1 in linkargs.count.used);
      });
    }
    return linkargs;
  }
  
  function _string(string) {
    
    return {structure: string};
  }
  
  function _role(thing, role) {
    thing.role = role;
    return thing;
  }
  
  function _with(thing, key, val) {
    thing.key = val;
    return thing;
  }

  // === ZOI functions === //

  function _zoi_assign_delim(word) {
    var a = word.word.replace(/\./gm, "").split(",");
    if (a.length > 0) _g_zoi_delim = a[a.length - 1];
    else _g_zoi_delim = "";
    return word;
  }

  function _zoi_check_quote(word) {
    if (Array.isArray(word)) word = _join(word);
    if (typeof(word) == "object") word = word.word || word.toString();
    if (!is_string(word)) {
      alert("ZOI word is not a string");
      return false;
    } else {
      try {
        var parsed = peg$parse(word.toLowerCase(), {startRule: "any_word"});
        return (parsed.word || parsed).replace(/\./gm, "") === _g_zoi_delim;
      } catch (e) {
        return false;
      }
    }
  }
  
  function _zoi_check_delim(word) {
    if (Array.isArray(word)) word = _join(word);
    if (typeof(word) == "object") word = word.word;
    if (!is_string(word)) {
      alert("ZOI word is not a string");
      return false;
    } else {
      word = word.replace(/\./gm, "").split(",");
      if (word.length > 0) word = word[word.length - 1];
      else word = "";
      return (word === _g_zoi_delim);
    }
  }
  
  function is_string(v) {
    return typeof v.valueOf() === 'string';
  }
}

text = intro_null free:free* t1:text_1? faho_clause EOF? { return [_empty(free), _empty(t1)] }

intro_null = expr:(spaces? su_clause* intro_si_clause) 

//; intro_sa_clause = SA_clause+ / any_word_SA_handling !(ZEI_clause SA_clause) intro_sa_clause
intro_si_clause = expr:(si_clause? SI_clause*)  
faho_clause = expr:((FAhO_clause dot_star)?) 

// Please note that the "text_1" item in the text_1 production does
// *not* match the BNF. This is due to a bug in the BNF.  The change
// here was made to match grammar.300
text_1 = expr:((NIhO_clause+ free* su_clause*)? paragraphs) 

paragraphs = expr:(paragraph? (NIhO_clause+ free* su_clause* paragraphs)?) 

paragraph = expr:(lone_jek? (tag BO_clause)? (I_clause lone_jek? (tag BO_clause)?)? statement (I_clause !lone_jek free* statement)*) 

statement = expr:(prenex statement / statement_1) 

statement_1 = expr:(statement_2 (I_clause lone_jek statement_2?)*) 

statement_2 = expr:(statement_3 (I_clause lone_jek? tag? BO_clause free* statement_2)?) 

statement_3 = expr:(tag? TUhE_clause free* text_1 TUhU_elidible free* / fragment / sentence) 

fragment = expr:(!term !tag quantifier / relative_clauses / links+ / !selbri linkargs) 

lone_jek = !gek joik_ek free*

prenex = expr:(terms? ZOhU_clause free*) 

sentence = head:terms? tail:bridi_tail {
  var fa_after_head = head && _count_fa(head.terms) || {};
  var fa_after_tail = _count_fa_tail(tail, fa_after_head.last || 1, fa_after_head.used || {});
  tail.fa_after_tail = fa_after_tail;
  var ret = {role: "bridi", structure: [head, tail], head: head, tail: tail, fa_after_head: fa_after_head, fa_after_tail: fa_after_tail};
  //var ret = {role: "bridi", structure: [head, tail], head: head, tail: tail};
  return ret;
}

sentence_no_count = head:terms? tail:bridi_tail {
  var ret = {structure: [head, tail], head: head, tail: tail};
  return ret;
}

sentence_sa = expr:(sentence_start? (!sentence_start (sa_word / SA_clause !sentence_start ) )* SA_clause &text_1) 

sentence_start = expr:(I_pre / NIhO_pre) 

subsentence_no_count = expr:(prenex subsentence_no_count / sentence_no_count) 

subsentence = expr:(tag? TUhE_clause free* text_1 TUhU_elidible free* / prenex subsentence / sentence) 

bridi_tail = bridi_tail_1 / VAU_elidible free*

bridi_tail_1 = start:bridi_tail_2 repeat:((gihek (tag:tag &KE_clause { return tag })? / GI_clause tag &KE_clause) !(tag? BO_clause) free* bridi_tail_2 tail_terms)* {
  return repeat.reduce(function (a, b) {
    a = _fill_jek(a, _fill_free(b[0][0], b[2]), b[3], b[0][1]);
    a.tail_terms = b[4];
    a.structure = a.structure.concat(a.tail_terms);
    return a;
  }, start);
}

//// EXP-MODIF: GI TAG BO + JACU
bridi_tail_2 = 
cu:CU_elidible cufree:free* quant:quantifier? meihi:NUhI_clause meihifree:free* &(selbri / CU_clause) tails:bridi_tail_1+ meiho:NUhU_elidible meihofree:free* tail_terms:tail_terms
{
  return {
    structure: [_fill_free(cu, cufree), quant, _fill_free(meihi, meihifree), tails, _fill_free(meiho, meihofree), tail_terms],
    tails: tails,
    tail_terms: tail_terms,
    quantifier: quant,
  }
}
/ cu:CU_elidible cufree:free* start:bridi_tail_3 repeat:((gihek tag? / GI_clause? tag) BO_clause free* bridi_tail_2 tail_terms)? {
  start.cu = _fill_free(cu, cufree);
  start.structure = [cu, _shell(start)];
  if (repeat) {
    start = _fill_jek(start, repeat[0][0], repeat[3], repeat[0][1], _fill_free(repeat[1], repeat[2]));
    start.tail_terms = repeat[4];
    start.structure = start.structure.concat(start.tail_terms);
  }
  return start;
}

//// EXP-MODIF: terms before selbri after cu
bridi_tail_3 = gek_sentence
  / (preterms:(terms CU_elidible free*)* selbri:selbri tail_terms:tail_terms {
  return {
    structure: [preterms, selbri, tail_terms],
    preterms: preterms.map(function (a) { return {terms: a[0].terms, cu: _fill_free(a[1], a[2])} }),
    selbri: selbri, tail_terms: tail_terms,
  }
}) / ke:KE_clause kefree:free* contents:bridi_tail kehe:KEhE_elidible kehefree:free* {
  return _precedence(_fill_free(ke, kefree), contents, _fill_free(kehe, kehefree));
}

gek_sentence = (gek:gek left:subsentence_no_count gik:gik right:subsentence_no_count tail_terms:tail_terms {
    gek = _fill_gek(gek, left, gik, right);
    gek.tail_terms = tail_terms;
    gek.structure = gek.structure.concat(tail_terms);
    return gek;
  }) 
  / (tag:tag* ke:KE_clause kefree:free* gek:gek_sentence kehe:KEhE_elidible kehefree:free* {
    gek = _duplicate_less_evil(gek);
    gek.ke = _fill_free(ke, kefree);
    gek.kehe = _fill_free(kehe, kehefree);
    gek.structure = [tag, ke, gek.structure, kehe];
    gek.selbri_tags = gek.selbri_tags ? tag.concat(gek.selbri_tags) : tag;
    return gek;
  }) 
  / (tag:tag+ &(!si_clause !zei_clause !bu_clause (NA_clause / GA_clause)) gek:gek_sentence {
    gek = _duplicate_less_evil(gek);
    gek.structure = [tag, gek.structure];
    gek.selbri_tags = gek.selbri_tags ? tag.concat(gek.selbri_tags) : tag;
    return gek;
  }) 
  / (na:NA_clause free:free* gek:gek_sentence { 
    gek = _duplicate_less_evil(gek);
    _fill_free(na, free);
    gek.structure = [na, gek.structure];
    gek.selbri_tags = gek.selbri_tags ? [na].concat(gek.selbri_tags) : [na];
    return gek;
  })

tail_terms = terms:terms? vau:VAU_elidible free:free*  {
  terms = terms || {terms: [], structure: [], elided: true};
  var ret = { terms: terms, vau: _fill_free(vau, free), structure: terms.elided ? [vau] : [terms, vau]};
  if (!_empty(terms.terms) && vau.elided) ret.elided = true;
  return ret;
}

terms = expr:terms_1+ { return { terms: expr, structure: expr } }

terms_1 = start:terms_2 repeat:(PEhE_clause free* joik_ek terms_2)* {
  repeat.forEach(function(r) {
    start.pehe = _fill_free(r[0], r[1]);
    start = _fill_jek(start, r[2], r[3], null, null, start.pehe);
  });
  return start;
}

terms_2 = start:abs_term repeat:(CEhE_clause free* abs_term)* {
  if (!_empty(repeat)) return start;
  start = [start];
  repeat.forEach(function(r) {
    var term = r[2];
    term.cehe = _fill_free(r[0], r[1]);
    start.push(term);
  });
  return {termset: "cehe", terms: start, structure: start.slice(1).reduce(function (a,b) { return a.concat([b.cehe, b]) }, [start[0]])};
}

term = tag_term / fa_elided_term

tag_term = start:(termset /
  (!gek tag:tag free:free* sumti:(
    sumti 
    / &{return options.faje} (jek:joik_ek sumti:sumti_3 { return _fill_jek(null, jek, sumti) })
    / &{return options.faje} relative_clauses
    / (ku:KU_elidible free:free* { return _fill_free(ku, free) })
    ) { return _term(_fill_free(tag, free), sumti) })
  / inverted_term / naku_term
  / (!(!sumti !gek_termset gek) !joik_ek !gihek na:NA_clause nafree:free* ku:KU_elidible kufree:free* { return _term(_fill_free(na, nafree), _fill_free(ku, kufree)) }) 
  / soi_term
) repeat:(joik_ek tag_term)* {
  repeat.forEach(function (r) {
    start = _fill_jek(start, r[0], r[1]);
  });
  return start;
}

abs_term = abs_tag_term / fa_elided_term

abs_tag_term = start:(termset /
  (!gek tag:tag free:free* !BO_clause !selbri !gek_sentence sumti:(
    sumti 
    / &{return options.faje} (jek:joik_ek sumti:sumti_3 { return _fill_jek(null, jek, sumti) })
    / &{return options.faje} relative_clauses
    / (ku:KU_elidible free:free* { return _fill_free(ku, free) })
    ) { return _term(_fill_free(tag, free), sumti) })
  / inverted_term / naku_term
  / (!selbri !(!sumti !gek_termset gek_sentence) !joik_ek !gihek na:NA_clause nafree:free* ku:KU_elidible kufree:free* { return _term(_fill_free(na, nafree), _fill_free(ku, kufree)) })
  / soi_term
) repeat:(joik_ek abs_tag_term)* {
  repeat.forEach(function (r) {
    start = _fill_jek(start, r[0], r[1]);
  });
  return start;
}

inverted_term = !gek sumti:sumti co:CO_clause tag:tag ku:KU_elidible free:free* { return _term(_fill_free(tag, free), sumti, co, ku) }

fa_elided_term = tag:FA_elidible boi:(&(number / lerfu_string) { return true })? sumti:sumti { return _term({tags: [tag], structure: [tag], implicit_fa: true, elided: true, boi: boi ? "boi" : ""}, sumti) }

naku_term = na:NA_clause nafree:free* ku:KU_clause kufree:free* { return _term(_fill_free(na, nafree), _fill_free(ku, kufree)) }

soi_term = soi:SOI_clause soifree:free* bridi:subsentence sehu:SEhU_elidible sehufree:free* { return {tag: _fill_free(soi, soifree), bridi: bridi, terminator: _fill_free(sehu, sehufree), structure: [soi, bridi, sehu]} }

termset = gek_termset 
  / NUhI_clause free* gek terms NUhU_elidible free* gik terms NUhU_elidible free*
  / (quantifier:quantifier? nuhi:KE_clause nuhifree:free* &(gek? tense_modal / termset) terms:terms nuhu:KEhE_elidible nuhufree:free* { return {
    termset: "nuhi", 
    quantifier: quantifier, 
    terms: terms.terms, 
    nuhi: _fill_free(nuhi, nuhifree), 
    nuhu: _fill_free(nuhu, nuhufree), 
    structure: [quantifier, nuhi, terms.structure, nuhu].filter(_empty),
  } }) 
  / (quantifier:quantifier? nuhi:NUhI_clause nuhifree:free* terms:terms nuhu:NUhU_elidible nuhufree:free* { return {
    termset: "nuhi", 
    quantifier: quantifier, 
    terms: terms.terms, 
    nuhi: _fill_free(nuhi, nuhifree), 
    nuhu: _fill_free(nuhu, nuhufree), 
    structure: [quantifier, nuhi, terms.structure, nuhu].filter(_empty),
  } }) 

gek_termset = gek:gek tgt:terms_gik_terms {
  return _fill_gek(gek, {structure: tgt.left, terms: tgt.left, termset: "gek"}, tgt.gik, {structure: tgt.right, terms: tgt.right, termset: "gek"});
}

terms_gik_terms = left:term middle:(gik / terms_gik_terms) right:term {
  if (middle.left) {
    middle.left.unshift(left);
    middle.right.push(right);
    return middle;
  }
  return {left: [left], gik: middle, right: [right]};
}

sumti = sumti:sumti_1 vuho:(VUhO_clause free* vuho_tail?)? {
  if (vuho) {
    sumti.vuho = _fill_free(vuho[0], vuho[1]);
    if (vuho[2]) {
      sumti.relative = vuho[2][0];
      sumti.structure = [_shell(sumti), sumti.vuho, sumti.relative];
      if (vuho[2][1]) {
        return _fill_jek(sumti, vuho[2][1][0], vuho[2][1][1]); // XXX UGLY UGLY UGLY
      }
      return sumti;
    }
    sumti.structure = [_shell(sumti), sumti.vuho];
  }
  return sumti;
}

vuho_tail = relative_clauses (joik_ek sumti)?

sumti_1 = sumti_2

sumti_2 = start:sumti_3 repeat:(joik_ek sumti_3)* {
  return repeat.reduce(function (a, b) { return _fill_jek(a, b[0], b[1]) }, start);
}

sumti_3 = start:sumti_4 repeat:(joik_ek? tag? BO_clause free* sumti_3)? {
  if (repeat) {
    return _fill_jek(start, repeat[0], repeat[4], repeat[1], _fill_free(repeat[2], repeat[3]));
  }
  return start;
}

sumti_4 = ke:KE_clause kefree:free* sumti:sumti kehe:KEhE_elidible kehefree:free*
    { return _precedence(_fill_free(ke, kefree), sumti, _fill_free(kehe, kehefree)) } 
  / sumti_5 / (gek:gek left:sumti gik:gik right:sumti_4 { return _role(_fill_gek(gek, left, gik, right), "sumti") }) 

//// EXP-MODIF: quantifier+gek_sentence
sumti_5 = (quantifier:quantifier? sumti:sumti_6 relative:relative_clauses? {
  return _sumti_five(quantifier, sumti, relative);
})
  / (quantifier:quantifier selbri:(
        (outer_relative:relative_clauses? selbri:selbri { return _relativized_selbri(selbri, null, outer_relative) }) 
        / gek_sentence / &CU_clause bridi_tail
      ) ku:KU_elidible free:free* relative:relative_clauses? {
    return {
      quantifier: quantifier,
      selbri: selbri,
      ku: _fill_free(ku, free),
      relative: relative && selbri.outer_relative ? _fill_jek(selbri.outer_relative, _fake_jek(), relative) : selbri.outer_relative || relative,
      structure: [[quantifier, selbri.outer_relative, selbri, ku].filter(_empty), relative].filter(_empty),
    }
  }) 

sumti_6 = simple_sumti
  / (!tag !selbri lerfu_string BOI_elidible free*)
  / lu:LU_clause text:text lihu:LIhU_elidible lihufree:free* { return {clause: "lu", structure: [lu, text, _fill_free(lihu, lihufree)], } }
  / !tag lahe_nahe relative_clauses? (sumti / term) LUhU_elidible free* 
  / (gadri:LE_clause free:free* tail:sumti_tail ku:KU_elidible kufree:free* {
    return {
      gadri: _fill_free(gadri, free),
      selbri: tail,
      ku: _fill_free(ku, kufree),
      structure: [gadri, tail.outer_relative, tail, ku].filter(_empty),
    };
  })
  / li_clause 
  / (LOhOI_clause free* subsentence KUhAU_elidible free*) 
  
lahe_nahe = (LAhE_clause / NAhE_clause) BO_clause? free*

simple_sumti = clause:(ZOI_clause / ZOhOI_clause / ZO_clause / LOhU_clause / KOhA_clause) free:free* { return _fill_free(_role(clause, "sumti"), free) }

li_clause = expr:(LI_clause free* mex LOhO_elidible free*)

//// EXP-MODIF: allow {lo mi e do vu'o noi brodi cu broda} (instead of the previous string) + adding gek_sentence
sumti_tail = 
  (rel:relative_clauses_nek? tail:sumti_tail_1 { 
    //var relative = rel && sumti ? _fill_jek(rel, _fake_jek(), _fake_nek(sumti)) : rel || sumti && _fake_nek(sumti);
    var copy = _duplicate_less_evil(tail);
    copy.outer_relative = rel;
    return copy;
  }) 
  / gek_sentence 
  / (&CU_clause tail:bridi_tail { return tail })

sumti_tail_1 = 
  (selbri:selbri rel:relative_clauses? { return _relativized_selbri(selbri, rel) }) 
  / (quant:quantifier selbri:selbri rel:relative_clauses? { return _relativized_selbri(selbri, rel, null, quant) })
  / (quant:quantifier sumti:sumti { return {quantifier: quant, sumti: sumti, structure: [quant, sumti],} }) 

relative_clauses = expr:(relative_clause (joik_ek free* relative_clause)* / gek relative_clauses gik relative_clauses) 

relative_clauses_nek = expr:(relative_clause_nek (joik_ek free* relative_clause_nek)* / gek relative_clauses gik relative_clauses) 

relative_clause = expr:(GOI_clause free* term GEhU_elidible free* / NOI_clause free* subsentence KUhO_elidible free* ) 

relative_clause_nek = relative_clause / GOI_elidible !quantifier &sumti term GEhU_elidible

selbri_relative_clauses = expr:(selbri_relative_clause (joik_ek free* selbri_relative_clause)* / gek selbri_relative_clauses gik selbri_relative_clauses) 

selbri_relative_clause = expr:(NOhOI_clause free* subsentence KUhOI_elidible free* ) 


selbri = tag:(tag / na:NA_clause free:free* { return _fill_free(na, free) })* selbri:selbri_1 { 
  if (_empty(tag)) {
    selbri = _duplicate_less_evil(selbri);
    selbri.structure = [tag, _shell(selbri)]; 
    selbri.selbri_tags = selbri.selbri_tags ? tag.concat(selbri.selbri_tags) : tag;
  }
  return selbri
}

selbri_1 = selbri_2

selbri_2 = start:selbri_3 repeat:(CO_clause free* selbri_3)* {
  return repeat.reduce(function(a, b) { return _tanru(b[2], a, _fill_free(b[0], b[1])) }, start);
}

selbri_3 = expr:(selbri_4+) { return expr.reduce(function(a, b) { return _tanru(a, b) }) }

selbri_4 = start:selbri_5 repeat:(joik_ek (selbri_5 / selbri_4_tag))* { return repeat.reduce(function(a, b) { return _fill_jek(a, b[0], b[1], b[1].internal_tag) }, start) }

selbri_4_tag = tag:tag? ke:KE_clause kefree:free* selbri:selbri_3 kehe:KEhE_elidible kehefree:free* {
  var r = _precedence(_fill_free(ke, kefree), selbri, _fill_free(kehe, kehefree));
  if (tag) r.internal_tag = tag;
  return r;
}

selbri_5 = start:selbri_6 repeat:(joik_ek? tag? BO_clause free* selbri_5)? {
  if (repeat) return _fill_jek(start, repeat[0], repeat[4], repeat[1], _fill_free(repeat[2], repeat[3]));
  return start;
}

selbri_6 = tanru_bo / tanru_guhe

tanru_bo = start:tanru_unit repeat:(BO_clause free* selbri_6)? {
  if (repeat) return _tanru(start, repeat[2], null, _fill_free(repeat[0], repeat[1]));
  return start;
}

tanru_guhe = nahe:NAhE_clause? free:free* guhek:guhek left:selbri gik:gik right:selbri_6  {
  if (nahe) guhek.nahe = _fill_free(nahe);
  return _fill_gek(guhek, left, gik, right);
}

//// EXP-MODIF: add of "selbri_relative_clauses?" for implementing NOhOI
tanru_unit = expr:(tanru_unit_1 (CEI_clause free* tanru_unit_1)* selbri_relative_clauses?) {
  if (_empty(expr[1])) expr[0].cei = expr[1];
  if (expr[2]) expr[0].selbri_relative_clauses = expr[2];
  return expr[0];
}

//// EXP-MODIF: implementation of foretought BE-clause
tanru_unit_1 = (unit:tanru_unit_2 linkargs:linkargs? { return linkargs ? _linkargs_attach(linkargs, unit) : unit }) 
  / (linkargs:linkargs? unit:tanru_unit_2 { if (linkargs) { linkargs.inverted = true; return _linkargs_attach(linkargs, unit) } return unit })

// ** zei is part of BRIVLA_clause
//// EXP-MODIF: brivla / cmevla merge + add of MEhOI_clause + add of "linkargs tanru_unit_1 / " (for {jai be broda}) + MEX simplification
tanru_unit_2 = expr:(
  (brivla:(BRIVLA_clause / MUhOI_clause / MEhOI_clause / GOhOI_clause) free:free* { return _place_shell(_fill_free(brivla, free)) }) 
  / (ke:KE_clause kefree:free* selbri:selbri_3 kehe:KEhE_elidible kehefree:free* { return _precedence(_fill_free(ke, kefree), selbri, _fill_free(kehe, kehefree)) }) 
  / (ME_clause free* (sumti / mex) MEhU_elidible free* MOI_clause? free*) 
  / (mex MOI_clause free*) 
  / (NUhA_clause free* operator) 
  / (se:SE_clause free:free* unit:tanru_unit_2 { return _place_se(_fill_free(se, free), unit) }) 
  / (JAI_clause free* tag? tanru_unit_2) 
  / (NAhE_clause free* tanru_unit_2) 
  / (NU_clause free* (joik_ek NU_clause free*)* subsentence KEI_elidible free*) 
  / (linkargs:linkargs unit:tanru_unit_1 { if (linkargs) { linkargs.inverted = true; return _linkargs_attach(linkargs, unit) } return unit })
  / MEIhE_clause free* sumti+ MEIhO_elidible
  ) { return expr.structure ? expr : {structure: expr} }

//// EXP-MODIF: Tsani: replace "term" with "term?" for allowing empty BE clauses
linkargs = be:BE_clause befree:free* term:term? links:links* beho:BEhO_elidible behofree:free* {
  var ret = {
    be: _fill_free(be, befree),
    terms: links.reduce(function (a, b) { return b.term ? a.concat(b.term) : a }, term ? [term] : []),
    beho: _fill_free(beho, behofree),
    structure: [[be, term]].concat(links).concat(beho),
  };
  ret.count = _count_fa(ret.terms, 2);
  return ret;
}

//// EXP-MODIF: Tsani: replace "term" with "term?" for allowing empty BE clauses
links =  bei:BEI_clause free:free* term:term? { return {bei: _fill_free(bei, free), term: term, structure: [bei, term]} }

quantifier = !selbri !sumti_6 mex:mex { return mex }

//// EXP-MODIF: MEX simplification
mex = expr:(mex_1 (operator mex_1)* ) { return expr[1].reduce(function (a, b) { return _fill_jek(a, b[0], b[1]) }, expr[0]); }

mex_1 = expr:( gek_mex (operator? tag? BO_clause free* mex_1)? ) { if (expr[1]) return _fill_jek(expr[0], expr[1][0], expr[1][4], expr[1][1], _fill_free(expr[1][2], expr[1][3])); return expr[0]; }

gek_mex = (gek:gek left:mex gik:gik right:mex_2 { return _fill_gek(gek, left, gik, right) }) / mex_2

mex_2 = expr:( number BOI_elidible free* / lerfu_string BOI_elidible free* / VEI_clause free* mex VEhO_elidible free* / NIhE_clause free* selbri TEhU_elidible free* / MOhE_clause sumti TEhU_elidible free* / lahe_nahe mex LUhU_elidible free* / (PEhO_clause free*)? operator mex+ KUhE_elidible free* / FUhA_clause rp_expression / JOhI_clause free* gek_mex+ TEhU_elidible free* ) 

rp_expression = expr:( mex (rp_expression operator)* ) 

operator = expr:operator_0 { return { structure: expr } } 

operator_0 = expr:(operator_1 (joik_ek operator_1 / joik_ek tag? KE_clause free* operator KEhE_elidible free*)*) 

operator_1 = expr:(operator_2 / guhek operator_1 gik operator_2 / operator_2 joik_ek? tag? BO_clause free* operator_1) 

operator_2 = expr:(mex_operator / KE_clause free* operator KEhE_elidible free*) 

//// EXP-MODIF: MEX simplification
mex_operator = expr:(SE_clause free* mex_operator / NAhE_clause free* mex_operator / MAhO_clause free* mex TEhU_elidible free* / NAhU_clause free* selbri TEhU_elidible free* / joik_ek free*) 

//// EXP-MODIF
number = number_initial / init:PA_clause fin:(PA_clause / &{return !options.lerfu} lerfu_word)* { return _string([init].concat(fin)) }

number_initial = NIhE_clause free* selbri TEhU_elidible free* / MOhE_clause free* sumti TEhU_elidible free*

lerfu_string = init:lerfu_word fin:(&{return !options.lerfu} PA_clause / lerfu_word)* { return _string([init].concat(fin)) }


// ** BU clauses are part of BY_clause
lerfu_word = expr:(BY_clause / LAU_clause lerfu_word / TEI_clause lerfu_string FOI_clause) 

//// EXP-MODIF - A/JA/JOI merge, gijek implementaton, add of JA_clause synonym of GIhA_clause
gihek = na:NA_clause? se:SE_clause? joi:(JOI_clause / GIhA_clause / gi_joi) {
  joi = _duplicate_less_evil(joi);
  var structure = [];
  if (_empty(na)) structure.push(joi.na = na);
  if (_empty(se)) structure.push(joi.se = se);
  structure.push(_shell(joi));
  joi.structure = structure;
  return joi;
}

gi_joi = gi:GI_clause joi:JOI_clause {
  joi = _duplicate_less_evil(joi);
  joi.gi = gi;
  joi.structure = [gi, _shell(joi)];
  return joi;
}

//// EXP-MODIF: A-JA-JOI merge
joik = gaho_pre:GAhO_clause* na:NA_clause? se:SE_clause? joi:JOI_clause gaho_post:GAhO_clause* {
  joi = _duplicate_less_evil(joi);
  var structure = [];
  if (_empty(gaho_pre)) structure.push(joi.gaho_pre = gaho_pre);
  if (_empty(na)) structure.push(joi.na = na);
  if (_empty(se)) structure.push(joi.se = se);
  structure.push(_shell(joi));
  if (_empty(gaho_post)) structure.push(joi.gaho_post = gaho_post);
  joi.structure = structure;
  return joi;
}

joik_ek = expr:(joik / VUhU_clause) free:free* { return _fill_free(expr, free) }

//// EXP-MODIF: Implementation of gaJA
gek = (gak joik_ek )
  / ((joik_ek / tag) gik )
  / (se:SE_clause? ga:GA_clause free:free* { if (se) { ga.se; ga.structure = [se, _shell(ga)] } return _fill_free(ga, free) }) 

//// EXP-ADD: GAJA
gak = expr:ga_clause free:free* { return _fill_free(expr, free) }

guhek = guk joik_ek
  / se:SE_clause? guha:GUhA_clause free:free* { if (_empty(se)) { guha.se = se; guha.structure = [se, _shell(guha)] } return _fill_free(guha, free) }

guk = expr:gu_clause free:free* { return _fill_free(expr, free) }

gik = expr:GI_clause free:free* { return _fill_free(expr, free) }

tag = start:tense_modal repeat:(joik_ek tense_modal)* {
  repeat.forEach(function (r) {
    start = _fill_jek(start, r[0], r[1]);
    start.tagged_fa = [].concat(start.left.tagged_fa).concat(start.right.tagged_fa); // FIXME: treat particular connectives
    start.last_fa = start.right.last_fa;
    if (start.right.implicit_fa) start.implicit_fa = true;
  });
  return start;
}

tag_ke = ke:KE_clause kefree:free* tag:tag kehe:KEhE_elidible? kehefree:free* {
  return _precedence(_fill_free(ke, kefree), tag, _fill_free(kehe, kehefree))
}

//// EXP-MODIF: MEX simplification
tense_modal = 
  guhek:guhek left:tag gik:gik right:(tag_ke / tense_modal) {
    return _fill_gek(guhek, left, gik, right);
  } / nahe:NAhE_clause* se:SE_clause? fehe:FEhE_clause*
    tag:(tag:(PU_clause / roi_tense / fiho_modal / FA_clause) free:free* { return _fill_free(tag, free) })+ {
  var r = {tags: tag, structure: tag};
  var last_fa = 0;
  var used_fa = {};
  var last_tag = tag[tag.length - 1];
  var tagged_fa = get_fa(last_tag);
  function get_fa(tag) {
    if (typeof tag.word != "string") return;
    if (tag.word.match(/^f[aeiou]$/))
      return _fa_letters[tag.word[1]];
  }
  tag.forEach(function (a) {
    var fa = get_fa(a);
    if (fa) {
      last_fa = fa;
      used_fa[fa] = true;
    }
  });
  if (last_fa) r.last_fa = last_fa;
  r.used_fa = used_fa;
  if (tagged_fa) r.tagged_fa = [tagged_fa];
  if (last_tag.elided) r.implicit_fa = true;
  if (last_tag.word && last_tag.word == "fai") r.tagged_fai = true;
  if (_empty(nahe)) r.nahe = nahe;
  if (_empty(se)) r.se = se;
  if (_empty(fehe)) r.fehe = fehe;
  r.structure = [nahe, se, fehe, tag].filter(_empty);
  return r;
}

roi_tense = num:mex_2 roi:ROI_clause { roi.number = num; roi.structure = [num, _shell(roi)]; return roi }

fiho_modal = fiho:FIhO_clause free:free* selbri:selbri fehu:FEhU_elidible { fiho.selbri = selbri; fiho.terminator = fehu; return { fiho: _fill_free(fiho), structure: [fiho, selbri, fehu], } }

//// EXP-MODIF: brivla/cmevla merge; MEX simplification
// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
free = indicators / free_vocative / free_mai / xi_clause

free_sei = sei:SEI_clause free:free* terms:(terms CU_elidible free*)* selbri:(selbri / gek_sentence) end:SEhU_elidible {
  var r = {
    clause: "free_sei",
    bridi: true,
    subsumed: [sei, free, terms, selbri, end], 
    selbri: selbri,
    terms: []
  };
  r.structure = [_fill_free(sei, free), terms, selbri, end];
  terms.forEach(function (head) {
    r.terms = r.terms.concat(head[0]);
    // FIXME don't throw away cu!
  });
  return r;
}

free_vocative = vocative (relative_clauses? selbri relative_clauses? / sumti)? DOhU_elidible

free_mai = mex:mex_2 mai:MAI_clause {
  mai.number = mex;
  mai.structure = [mex, _shell(mai)];
  return mai;
}

free_to = to:TO_clause text:text toi:TOI_elidible {
  to.clause = "free_to";
  to.text = text;
  to.terminator = toi;
  to.structure = [_shell(to), text, toi];
  return to;
}

//// EXP-MODIF: MEX simplification
xi_clause = xi:XI_clause free:free* mex:mex_2 { xi.number = mex; _fill_free(xi, free); xi.structure = [_shell(xi), mex]; return xi }

vocative = (coi:COI_clause+ doi:DOI_elidible { doi.coi = coi; doi.structure = coi.concat(_shell(doi)); return doi }) / DOI_clause

indicators = expr:(FUhE_clause / UI_clause / CAI_clause / NAI_clause / FUhO_clause / free_sei / free_to / LOhAI_clause
)+ !BU_clause { return expr }

// ****************
// Magic Words
// ****************

zei_clause = pre:pre_clause_no_dot post:zei_clause_no_pre { post.pre = pre; post.structure = (post.post ? [pre, _shell(post), post.post.indicators] : [pre, _shell(post)]).filter(_empty); return post }

zei_clause_no_pre = 
pre:pre_zei_bu 
bu:(z:zei_tail? b:bu_tail { return {zei_tail: z, bu_tail: b} })* 
tail:zei_tail 
post:post_clause {
  var r = {selmaho: "BRIVLA", word: pre.word, subsumed: [pre], post: post};
  bu.forEach(function (bu) {
    if (bu.zei_tail) {
      r.subsumed = r.subsumed.concat(bu.zei_tail.subsumed);
      r.word += bu.zei_tail.string;
    }
    r.subsumed = r.subsumed.concat(bu.bu_tail.subsumed);
    r.word += bu.bu_tail.string;
  });
  r.subsumed = r.subsumed.concat(tail.subsumed);
  if (options.format == "text")
    r.word = r.word + tail.string;
  else
    r.word = "[" + r.word + tail.string + "]";
  return r;
}
// zei_clause_no_SA = pre_zei_bu_no_SA (zei_tail? bu_tail)* zei_tail

bu_clause = pre:pre_clause_no_dot post:bu_clause_no_pre { post.pre = pre; post.structure = (post.post ? [pre, _shell(post), post.post.indicators] : [pre, _shell(post)]).filter(_empty); return post }
bu_clause_no_pre = pre:pre_zei_bu zei:(b:bu_tail? z:zei_tail { return {bu_tail: b, zei_tail: z} })* tail:bu_tail post:post_clause {
  var r = {selmaho: "BY", word: pre.word, subsumed: [pre], post: post };
  zei.forEach(function (zei) {
    if (zei.bu_tail) {
      r.subsumed = r.subsumed.concat(zei.bu_tail.subsumed);
      r.word += zei.bu_tail.string;
    }
    r.subsumed = r.subsumed.concat(zei.zei_tail.subsumed);
    r.word += zei.zei_tail.string;
  });
  r.subsumed = r.subsumed.concat(tail.subsumed);
  if (options.format == "text")
    r.word = r.word + tail.string;
  else
    r.word = "[" + r.word + tail.string + "]";
  return r;
}
// bu_clause_no_SA = pre_zei_bu_no_SA (bu_tail? zei_tail)* bu_tail

zei_tail = expr:(ZEI_clause any_word)+ {
  var r = {string: "", subsumed: []};
  expr.forEach(function (pair) {
    r.string += " zei " + pair[1].word;
    r.subsumed.push(pair[0]);
    r.subsumed.push(pair[1]);
  });
  return r;
}
bu_tail = expr:BU_clause+ {
  return {
    subsumed: expr,
    string: expr.reduce(function(a, b) { return a + " " + b.word }, "")
  }
}

pre_zei_bu = !BU_clause !ZEI_clause !SI_clause !SA_clause !FAhO_clause word:any_word_SA_handling si:si_clause? {
  if (si) word.si = si;
  return word;
}
// LOhU_pre / ZO_pre / ZOI_pre / !ZEI_clause !BU_clause !FAhO_clause !SI_clause !SA_clause !SU_clause any_word_SA_handling si_clause?
// pre_zei_bu_no_SA = LOhU_pre / ZO_pre / ZOI_pre / !ZEI_clause !BU_clause !FAhO_clause !SI_clause !SA_clause !SU_clause any_word si_clause?

dot_star = expr:(.*) { return _join(expr) }

// __ General Morphology Issues
//
// 1.  Spaces (including '.y') and UI are eaten *after* a word.
//
// 3.  BAhE is eaten *before* a word.

// Handling of what can go after a cmavo
post_clause = spaces? si:si_clause? !ZEI_clause !BU_clause indicators:indicators? {
  var r = {};
  if (si) r.si = si;
  if (indicators) r.indicators = indicators;
  return (r.si || r.indicators) && r;
}
indicator_post_clause = !BU_clause spaces? si:si_clause? !ZEI_clause !BU_clause {
  return si && {si: si};
}

pre_clause = BAhE_clause* pre_dot
pre_dot = (&(nucleus / cmevla) {return "."})?
pre_clause_no_dot = a:BAhE_clause* { return _empty(a) && [a, null] }

//// EXP-DELETION: brivla/cmevla merge
//any_word_SA_handling = BRIVLA_pre / known_cmavo_SA / !known_cmavo_pre CMAVO_pre / CMEVLA_pre
any_word_SA_handling = BRIVLA_pre / known_cmavo_SA / CMAVO_pre

//// EXP-DEL: LA_pre, for brivla/cmevla merge
known_cmavo_SA = BAhE_pre / BE_pre / BEI_pre / BEhO_pre / BO_pre / BOI_pre / BU_pre / BY_pre / CAI_pre / CEI_pre / CEhE_pre / CO_pre / COI_pre / CU_pre / DOI_pre / DOhU_pre / FA_pre / FEhE_pre / FEhU_pre / FIhO_pre / FOI_pre / FUhA_pre / FUhE_pre / FUhO_pre / GA_pre / GAhO_pre / GEhU_pre / GI_pre / GIhA_pre / GOI_pre / GOhA_pre / GOhOI_pre / GUhA_pre / I_pre / JAI_pre / JOI_pre / JOhI_pre / KE_pre / KEI_pre / KEhE_pre / KOhA_pre / KU_pre / KUhE_pre / KUhO_pre / LAU_pre / LE_pre / LEhU_pre / LI_pre / LIhU_pre / LOhO_pre / LOhU_pre / LU_pre / LUhU_pre / MAI_pre / MAhO_pre / ME_pre / MEhOI_pre / MEhU_pre / MEIhE_pre / MEIhO_pre / MOI_pre / MOhE_pre / MUhOI_pre / NA_pre / NAI_pre / NAhE_pre / NAhU_pre / NIhE_pre / NIhO_pre / NOI_pre / NU_pre / NUhA_pre / NUhI_pre / NUhU_pre / PA_pre / PEhE_pre / PEhO_pre / PU_pre / ROI_pre / SA_pre / SE_pre / SEI_pre / SEhU_pre / SI_clause / SOI_pre / SU_pre / TEI_pre / TEhU_pre / TO_pre / TOI_pre / TUhE_pre / TUhU_pre / UI_pre / VAU_pre / VEI_pre / VEhO_pre / VUhO_pre / VUhU_pre / XI_pre / ZEI_pre / ZO_pre / ZOI_pre / ZOhOI_pre / ZOhU_pre

// Handling of spaces and things like spaces.
// ___ SPACE ___
// Do *NOT* delete the line above!

// SU clauses
su_clause = (erasable_clause / su_word)* SU_clause !SI_clause

// Handling of SI and interactions with zo and lo'u...le'u

si_clause = ((erasable_clause / si_word / SA_clause) si_clause? SI_clause)+

erasable_clause = expr:(bu_clause_no_pre !ZEI_clause !BU_clause / zei_clause_no_pre !ZEI_clause !BU_clause) {return {erasable: expr} }

sa_word = pre_zei_bu

si_word = pre_zei_bu

su_word = !NIhO_clause !LU_clause !TUhE_clause !TO_clause !SU_clause !FAhO_clause any_word_SA_handling


// ___ ELIDIBLE TERMINATORS ___  (EXPERIMENTAL)

BEhO_elidible = expr:(BEhO_clause?) {return expr || _elided("BEhO");}
BOI_elidible = expr:(BOI_clause?)   {return expr || _elided("BOI");}
CU_elidible = expr:(CU_clause?)     {return expr || _elided("CU");}
DOI_elidible = expr:(DOI_clause?) {return expr || _elided("DOI");}
DOhU_elidible = expr:(DOhU_clause?) {return expr || _elided("DOhU");}
FA_elidible = expr:(FA_clause?) {return expr || {selmaho: "FA", word: "fi'a", elided: true};}
FEhU_elidible = expr:(FEhU_clause?) {return expr || _elided("FEhU");}
// FOI and FUhO are never elidible
GEhU_elidible = expr:(GEhU_clause?) {return expr || _elided("GEhU");}
GOI_elidible = expr:(GEhU_clause?) {return expr || {selmaho: "GOI", word: "ne", elided: true};}
KEI_elidible = expr:(KEI_clause?)   {return expr || _elided("KEI");}
KEhE_elidible = expr:(KEhE_clause?) {return expr || _elided("KEhE");}
KU_elidible = expr:(KU_clause?)     {return expr || _elided("KU");}
KUhE_elidible = expr:(KUhE_clause?) {return expr || _elided("KUhE");}
KUhO_elidible = expr:(KUhO_clause?) {return expr || _elided("KUhO");}
// LEhU is never elidible
LIhU_elidible = expr:(LIhU_clause?) {return expr || _elided("LIhU");}
LOhO_elidible = expr:(LOhO_clause?) {return expr || _elided("LOhO");}
LUhU_elidible = expr:(LUhU_clause?) {return expr || _elided("LUhU");}
MEhU_elidible = expr:(MEhU_clause?) {return expr || _elided("MEhU");}
MEIhO_elidible = expr:(MEIhO_clause?) {return expr || _elided("MEIhO");}
NUhU_elidible = expr:(NUhU_clause?) {return expr || _elided("NUhU");}
SEhU_elidible = expr:(SEhU_clause?) {return expr || _elided("SEhU");}
TEhU_elidible = expr:(TEhU_clause?) {return expr || _elided("TEhU");}
TOI_elidible = expr:(TOI_clause?)   {return expr || _elided("TOI");}
TUhU_elidible = expr:(TUhU_clause?) {return expr || _elided("TUhU");}
VAU_elidible = expr:(VAU_clause?)   {return expr || _elided("VAU");}
VEhO_elidible = expr:(VEhO_clause?) {return expr || _elided("VEhO");}

KUhOI_elidible = expr:(KUhOI_clause?) {return expr || _elided("KUhOI");}
KUhAU_elidible = expr:(KUhAU_clause?) {return expr || _elided(options.po ? "POhE" : "KUhAU");}


// ___ SELMAHO ___
// Do *NOT* delete the line above!

BRIVLA_clause = (pre:BRIVLA_pre post:post_clause { return _word_post(pre, post) }) / zei_clause
BRIVLA_pre = pre:pre_clause word:(BRIVLA / GOhA) spaces? { return _word_pre(word, pre) }
// BRIVLA_no_SA_handling = pre_clause BRIVLA post_clause / zei_clause_no_SA

CMAVO_clause = pre:CMAVO_pre post:post_clause { return _word_post(pre, post) }
CMAVO_pre = pre:pre_clause word:CMAVO spaces? { return _word_pre(word, pre) }
// CMAVO_no_SA_handling = pre_clause CMAVO post_clause

//         next word intensifier 
BAhE_clause = pre:BAhE_pre post:BAhE_post { if (post) pre.si = post; return pre }
BAhE_pre = word:BAhE spaces? { return _word_pre(word, null) }
BAhE_post = si:si_clause? !ZEI_clause !BU_clause { return si }
// BAhE_no_SA_handling = BAhE spaces? BAhE_post

//         sumti link to attach sumti to a selbri 
BE_clause = pre:BE_pre post:post_clause  { return _word_post(pre, post) }
BE_pre = pre:pre_clause word:BE spaces? { return _word_pre(word, pre) }
// BE_no_SA_handling = pre_clause BE post_clause

//         multiple sumti separator between BE, BEI 
BEI_clause = pre:BEI_pre post:post_clause { return _word_post(pre, post) }
BEI_pre = pre:pre_clause word:BEI spaces? { return _word_pre(word, pre) }
// BEI_no_SA_handling = pre_clause BEI post_clause

//         terminates BEBEI specified descriptors 
BEhO_clause = pre:BEhO_pre post:indicator_post_clause { return _word_post(pre, post) }
BEhO_pre = pre:pre_clause word:BEhO spaces? { return _word_pre(word, pre) }
// BEhO_no_SA_handling = pre_clause BEhO post_clause

//         joins two units with shortest scope 
BO_clause = pre:BO_pre post:post_clause  { return _word_post(pre, post) }
BO_pre = pre:pre_clause word:BO spaces? { return _word_pre(word, pre) }
// BO_no_SA_handling = pre_clause BO post_clause

//         number or lerfu_string terminator 
BOI_clause = pre:BOI_pre post:indicator_post_clause { return _word_post(pre, post) }
BOI_pre = pre:pre_clause word:BOI spaces? { return _word_pre(word, pre) }
// BOI_no_SA_handling = pre_clause BOI post_clause

//         turns any word into a BY lerfu word 
BU_clause = pre:BU_pre post:BU_post { return _word_post(pre, post) }
// BU_clause_no_SA = BU_pre_no_SA BU BU_post
BU_pre = pre:pre_clause word:BU spaces? { return _word_pre(word, pre) }
// BU_pre_no_SA = pre_clause
BU_post = spaces?
// BU_no_SA_handling = pre_clause BU spaces?

//         individual lerfu words 
BY_clause = (pre:BY_pre post:post_clause { return _word_post(pre, post) }) / bu_clause
BY_pre = pre:pre_clause word:BY spaces? { return _word_pre(word, pre) }
// BY_no_SA_handling = pre_clause BY post_clause / bu_clause_no_SA

//         afterthought intensity marker 
CAI_clause = pre:CAI_pre post:indicator_post_clause { return _word_post(pre, post) }
CAI_pre = pre:pre_clause word:CAI spaces? { return _word_pre(word, pre) }
// CAI_no_SA_handling = pre_clause CAI post_clause

//         pro_bridi assignment operator 
CEI_clause = pre:CEI_pre post:post_clause { return _word_post(pre, post) }
CEI_pre = pre:pre_clause word:CEI spaces? { return _word_pre(word, pre) }
// CEI_no_SA_handling = pre_clause CEI post_clause

//         afterthought term list connective 
CEhE_clause = pre:CEhE_pre post:post_clause { return _word_post(pre, post) }
CEhE_pre = pre:pre_clause word:CEhE spaces? { return _word_pre(word, pre) }
// CEhE_no_SA_handling = pre_clause CEhE post_clause

//         tanru inversion  
CO_clause = pre:CO_pre post:post_clause { return _word_post(pre, post) }
CO_pre = pre:pre_clause word:CO spaces? { return _word_pre(word, pre) }
// CO_no_SA_handling = pre_clause CO post_clause

COI_clause = pre:COI_pre post:post_clause { return _word_post(pre, post) }
COI_pre = pre:pre_clause word:COI spaces? { return _word_pre(word, pre) }
// COI_no_SA_handling = pre_clause COI post_clause

//         separator between head sumti and selbri 
CU_clause = pre:CU_pre post:post_clause { return _word_post(pre, post) }
CU_pre = pre:pre_clause word:CU spaces? { return _word_pre(word, pre) }
// CU_no_SA_handling = pre_clause CU post_clause

//         vocative marker
DOI_clause = pre:DOI_pre post:post_clause { return _word_post(pre, post) }
DOI_pre = pre:pre_clause word:DOI spaces? { return _word_pre(word, pre) }
// DOI_no_SA_handling = pre_clause DOI post_clause

//         terminator for DOI_marked vocatives 
DOhU_clause = pre:DOhU_pre post:indicator_post_clause { return _word_post(pre, post) }
DOhU_pre = pre:pre_clause word:DOhU spaces? { return _word_pre(word, pre) }
// DOhU_no_SA_handling = pre_clause DOhU post_clause


//         modifier head generic case tag 
FA_clause = pre:FA_pre post:post_clause { return _word_post(pre, post) }
FA_pre = pre:pre_clause word:FA spaces? { return _word_pre(word, pre) }
// FA_no_SA_handling = pre_clause FA post_clause

//         normally elided 'done pause' to indicate end
//                                    of utterance string 

FAhO_clause = pre:pre_clause word:FAhO spaces? { return _word_pre(pre, word) }

//         space interval mod flag 
FEhE_clause = pre:FEhE_pre post:post_clause { return _word_post(pre, post) }
FEhE_pre = pre:pre_clause word:FEhE spaces? { return _word_pre(word, pre) }
// FEhE_no_SA_handling = pre_clause FEhE post_clause

//         ends bridi to modal conversion 
FEhU_clause = pre:FEhU_pre post:indicator_post_clause { return _word_post(pre, post) }
FEhU_pre = pre:pre_clause word:FEhU spaces? { return _word_pre(word, pre) }
// FEhU_no_SA_handling = pre_clause FEhU post_clause

//         marks bridi to modal conversion 
FIhO_clause = pre:FIhO_pre post:post_clause { return _word_post(pre, post) }
FIhO_pre = pre:pre_clause word:FIhO spaces? { return _word_pre(word, pre) }
// FIhO_no_SA_handling = pre_clause FIhO post_clause

//         end compound lerfu 
FOI_clause = pre:FOI_pre post:post_clause { return _word_post(pre, post) }
FOI_pre = pre:pre_clause word:FOI spaces? { return _word_pre(word, pre) }
// FOI_no_SA_handling = pre_clause FOI post_clause

//         reverse Polish flag 
FUhA_clause = pre:FUhA_pre post:post_clause { return _word_post(pre, post) }
FUhA_pre = pre:pre_clause word:FUhA spaces? { return _word_pre(word, pre) }
// FUhA_no_SA_handling = pre_clause FUhA post_clause

//         open long scope for indicator 
FUhE_clause = pre:FUhE_pre post:indicator_post_clause { var ret = _word_post(pre, post); ret.fuhe = ++_g_fuhe; return ret }
FUhE_pre = pre:pre_clause word:FUhE spaces? { return _word_pre(word, pre) }
// FUhE_no_SA_handling = pre_clause FUhE post_clause

//         close long scope for indicator 
FUhO_clause = pre:FUhO_pre post:indicator_post_clause { if (_g_fuhe < 1) throw "FUhO requires FUhE to its left"; var ret = _word_post(pre, post); ret.fuhe = _g_fuhe--; return ret }
FUhO_pre = pre:pre_clause word:FUhO spaces? { return _word_pre(word, pre) }
// FUhO_no_SA_handling = pre_clause FUhO post_clause


//         geks; forethought logical connectives 
GA_clause = pre:GA_pre post:post_clause { return _word_post(pre, post) }
GA_pre = pre:pre_clause word:GA spaces? { return _word_pre(word, pre) }
// GA_no_SA_handling = pre_clause GA post_clause

//         openclosed interval markers for BIhI 
GAhO_clause = pre:GAhO_pre post:post_clause { return _word_post(pre, post) }
GAhO_pre = pre:pre_clause word:GAhO spaces? { return _word_pre(word, pre) }
// GAhO_no_SA_handling = pre_clause GAhO post_clause

//         marker ending GOI relative clauses 
GEhU_clause = pre:GEhU_pre post:indicator_post_clause { return _word_post(pre, post) }
GEhU_pre = pre:pre_clause word:GEhU spaces? { return _word_pre(word, pre) }
// GEhU_no_SA_handling = pre_clause GEhU post_clause

//         forethought medial marker 
GI_clause = pre:GI_pre post:post_clause { return _word_post(pre, post) }
GI_pre = pre:pre_clause word:GI spaces? { return _word_pre(word, pre) }
// GI_no_SA_handling = pre_clause GI post_clause

//         logical connectives for bridi_tails 
GIhA_clause = pre:GIhA_pre post:post_clause { return _word_post(pre, post) }
GIhA_pre = pre:pre_clause word:GIhA spaces? { return _word_pre(word, pre) }
// GIhA_no_SA_handling = pre_clause GIhA post_clause

//         attaches a sumti modifier to a sumti 
GOI_clause = pre:GOI_pre post:post_clause { return _word_post(pre, post) }
GOI_pre = pre:pre_clause word:GOI spaces? { return _word_pre(word, pre) }
// GOI_no_SA_handling = pre_clause GOI post_clause

//         pro_bridi 
GOhA_clause = pre:GOhA_pre post:post_clause { return _word_post(pre, post) }
GOhA_pre = pre:pre_clause word:GOhA spaces? { return _word_pre(word, pre) }
// GOhA_no_SA_handling = pre_clause GOhA post_clause

//         GEK for tanru units, corresponds to JEKs 
GUhA_clause = pre:GUhA_pre post:post_clause { return _word_post(pre, post) }
GUhA_pre = pre:pre_clause word:GUhA spaces? { return _word_pre(word, pre) }
// GUhA_no_SA_handling = pre_clause GUhA post_clause


//         sentence link 
I_clause = sa:sentence_sa* pre:I_pre post:post_clause { return _word_post(pre, post, sa) }
I_pre = pre:pre_clause word:I spaces? { return _word_pre(word, pre) }
// I_no_SA_handling = pre_clause I post_clause

//         modal conversion flag 
JAI_clause = pre:JAI_pre post:post_clause { return _word_post(pre, post) }
JAI_pre = pre:pre_clause word:JAI spaces? { return _word_pre(word, pre) }
// JAI_no_SA_handling = pre_clause JAI post_clause

//         flags an array operand 
JOhI_clause = pre:JOhI_pre post:post_clause { return _word_post(pre, post) }
JOhI_pre = pre:pre_clause word:JOhI spaces? { return _word_pre(word, pre) }
// JOhI_no_SA_handling = pre_clause JOhI post_clause

//         non_logical connectives 
JOI_clause = pre:JOI_pre post:post_clause { return _word_post(pre, post) }
JOI_pre = pre:pre_clause word:JOI spaces? { return _word_pre(word, pre) }
// JOI_no_SA_handling = pre_clause JOI post_clause


//         left long scope marker 
KE_clause = pre:KE_pre post:post_clause { return _word_post(pre, post) }
KE_pre = pre:pre_clause word:KE spaces? { return _word_pre(word, pre) }
// KE_no_SA_handling = pre_clause KE post_clause

//         right terminator for KE groups 
KEhE_clause = pre:KEhE_pre post:indicator_post_clause { return _word_post(pre, post) }
KEhE_pre = pre:pre_clause word:KEhE spaces? { return _word_pre(word, pre) }
// KEhE_no_SA_handling = pre_clause KEhE post_clause

//         right terminator, NU abstractions 
KEI_clause = pre:KEI_pre post:indicator_post_clause { return _word_post(pre, post) }
KEI_pre = pre:pre_clause word:KEI spaces? { return _word_pre(word, pre) }
KEI_no_SA_handling = pre_clause KEI post_clause

//         sumti anaphora 
KOhA_clause = pre:KOhA_pre post:post_clause { return _word_post(pre, post) }
KOhA_pre = pre:pre_clause word:KOhA spaces? { return _word_pre(word, pre) }
// KOhA_no_SA_handling = pre_clause KOhA spaces?

//         right terminator for descriptions, etc. 
KU_clause = pre:KU_pre post:indicator_post_clause { return _word_post(pre, post) }
KU_pre = pre:pre_clause word:KU spaces? { return _word_pre(word, pre) }
// KU_no_SA_handling = pre_clause KU post_clause

//         MEX forethought delimiter 
KUhE_clause = pre:KUhE_pre post:post_clause { return _word_post(pre, post) }
KUhE_pre = pre:pre_clause word:KUhE spaces? { return _word_pre(word, pre) }
// KUhE_no_SA_handling = pre_clause KUhE post_clause

//         right terminator, NOI relative clauses 
KUhO_clause = pre:KUhO_pre post:indicator_post_clause { return _word_post(pre, post) }
KUhO_pre = pre:pre_clause word:KUhO spaces? { return _word_pre(word, pre) }
// KUhO_no_SA_handling = pre_clause KUhO post_clause

//         lerfu prefixes 
LAU_clause = pre:LAU_pre post:post_clause { return _word_post(pre, post) }
LAU_pre = pre:pre_clause word:LAU spaces? { return _word_pre(word, pre) }
// LAU_no_SA_handling = pre_clause LAU post_clause

//         sumti qualifiers
LAhE_clause = pre:LAhE_pre post:post_clause { return _word_post(pre, post) }
LAhE_pre = pre:pre_clause word:LAhE spaces? { return _word_pre(word, pre) }
// LAhE_no_SA_handling = pre_clause LAhE post_clause

//         sumti descriptors 
LE_clause = pre:LE_pre post:post_clause { return _word_post(pre, post) }
LE_pre = pre:pre_clause word:LE spaces? { return _word_pre(word, pre) }
// LE_no_SA_handling = pre_clause LE post_clause

//         possibly ungrammatical text right quote 
LEhU_clause = pre:LEhU_pre post:LEhU_post { return _word_post(pre, post) }
LEhU_pre = pre:pre_clause word:LEhU spaces? { return _word_pre(word, pre) }
LEhU_post = spaces?
// LEhU_clause_no_SA = LEhU_pre_no_SA LEhU_post
// LEhU_pre_no_SA = pre_clause LEhU spaces?
// LEhU_no_SA_handling = pre_clause LEhU post_clause

//         convert number to sumti 
LI_clause = pre:LI_pre post:post_clause { return _word_post(pre, post) }
LI_pre = pre:pre_clause word:LI spaces? { return _word_pre(word, pre) }
// LI_no_SA_handling = pre_clause LI post_clause

//         grammatical text right quote 
LIhU_clause = pre:LIhU_pre post:indicator_post_clause { return _word_post(pre, post) }
LIhU_pre = pre:pre_clause word:LIhU spaces? { return _word_pre(word, pre) }
// LIhU_no_SA_handling = pre_clause LIhU post_clause

//         elidable terminator for LI 
LOhO_clause = pre:LOhO_pre post:indicator_post_clause { return _word_post(pre, post) }
LOhO_pre = pre:pre_clause word:LOhO spaces? { return _word_pre(word, pre) }
// LOhO_no_SA_handling = pre_clause LOhO post_clause

//         possibly ungrammatical text left quote 
LOhU_clause = pre:LOhU_pre post:post_clause { return _word_post(pre, post) }
LOhU_pre = pre:pre_clause word:LOhU spaces? quoted:(!LEhU w:any_word { return w })* subsumed:LEhU_clause spaces? {
  word.quoted = quoted || [];
  word.subsumed = subsumed;
  word.single_word = word.word;
  if (options.format == "text")
    word.word = word.word + " " + quoted.map(_bracket).join(" ") + " " + subsumed.word;
  else
    word.word = "[" + word.word + " " + quoted.map(_bracket).join(" ") + " " + subsumed.word + "]";
  return _word_pre(word, pre);
}

eternal_lohu = any_word*
// LOhU_no_SA_handling = pre_clause LOhU spaces? (!LEhU any_word)* LEhU_clause spaces?

// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
//         possibly ungrammatical replacement expression
LOhAI_clause = pre:LOhAI_pre post:post_clause { return _word_post(pre, post) }
LOhAI_pre = pre:pre_clause subsumed:LOhAI_quote* word:LEhAI spaces? {
  if (subsumed) word.subsumed = subsumed;
  return _word_pre(word, pre);
}
LOhAI_quote = word:LOhAI spaces? quoted:(!LOhAI !LEhAI w:any_word { return w })* {
  if (quoted) word.quoted = quoted;
  return word;
}

//         grammatical text left quote 
LU_clause = pre:LU_pre post:LU_post { return _word_post(pre, post) }
LU_pre = pre:pre_clause word:LU spaces? { return _word_pre(word, pre) }
LU_post = spaces?
// LU_no_SA_handling = pre_clause LU post_clause

//         LAhE close delimiter 
LUhU_clause = pre:LUhU_pre post:indicator_post_clause { return _word_post(pre, post) }
LUhU_pre = pre:pre_clause word:LUhU spaces? { return _word_pre(word, pre) }
// LUhU_no_SA_handling = pre_clause LUhU post_clause


//         change MEX expressions to MEX operators 
MAhO_clause = pre:MAhO_pre post:post_clause { return _word_post(pre, post) }
MAhO_pre = pre:pre_clause word:MAhO spaces? { return _word_pre(word, pre) }
// MAhO_no_SA_handling = pre_clause MAhO post_clause

//         change numbers to utterance ordinals 
MAI_clause = pre:MAI_pre post:indicator_post_clause { return _word_post(pre, post) }
MAI_pre = pre:pre_clause word:MAI spaces? { return _word_pre(word, pre) }
// MAI_no_SA_handling = pre_clause MAI post_clause

//         converts a sumti into a tanru_unit 
ME_clause = pre:ME_pre post:post_clause { return _word_post(pre, post) }
ME_pre = pre:pre_clause word:ME spaces? { return _word_pre(word, pre) }
// ME_no_SA_handling = pre_clause ME post_clause

//         terminator for ME 
MEhU_clause = pre:MEhU_pre post:indicator_post_clause { return _word_post(pre, post) }
MEhU_pre = pre:pre_clause word:MEhU spaces? { return _word_pre(word, pre) }
// MEhU_no_SA_handling = pre_clause MEhU post_clause

//         change sumti to operand, inverse of LI 
MOhE_clause = pre:MOhE_pre post:post_clause { return _word_post(pre, post) }
MOhE_pre = pre:pre_clause word:MOhE spaces? { return _word_pre(word, pre) }
// MOhE_no_SA_handling = pre_clause MOhE post_clause

MEIhE_clause = pre:MEIhE_pre post:post_clause { return _word_post(pre, post) }
MEIhE_pre = pre:pre_clause word:MEIhE spaces? { return _word_pre(word, pre) }
// MEIhE_no_SA_handling = pre_clause MEIhE post_clause

MEIhO_clause = pre:MEIhO_pre post:indicator_post_clause { return _word_post(pre, post) }
MEIhO_pre = pre:pre_clause word:MEIhO spaces? { return _word_pre(word, pre) }
// MEIhO_no_SA_handling = pre_clause MEIhO post_clause

//         change number to selbri 
MOI_clause = pre:MOI_pre post:indicator_post_clause { return _word_post(pre, post) }
MOI_pre = pre:pre_clause word:MOI spaces? { return _word_pre(word, pre) }
// MOI_no_SA_handling = pre_clause MOI post_clause

MUhOI_clause = pre:MUhOI_pre post:post_clause { return _word_post(pre, post) }
//// EXP-EDIT: ZOI fix
MUhOI_pre = pre:pre_clause word:MUhOI spaces? open:zoi_open spaces? quoted:zoi_word* close:zoi_close spaces? {
  word.subsumed = [open, close];
  word.quoted = quoted || [];
  word.quoted.word = word.quoted.join(" ");
  word.single_word = word.word;
  if (options.format == "text")
    word.word = word.word + " " + open.word + " " + word.quoted.word + " " + close.word;
  else
    word.word = "[" + word.word + " " + open.word + " " + word.quoted.word + " " + close.word + "]";
  return _word_pre(word, pre)
}

//         bridi negation  
NA_clause = pre:NA_pre post:post_clause { return _word_post(pre, post) }
NA_pre = pre:pre_clause word:NA spaces? { return _word_pre(word, pre) }
// NA_no_SA_handling = pre_clause NA post_clause

//         attached to words to negate them 
NAI_clause = pre:NAI_pre post:indicator_post_clause { return _word_post(pre, post) }
NAI_pre = pre:pre_clause word:NAI spaces? { return _word_pre(word, pre) }
// NAI_no_SA_handling = pre_clause NAI post_clause

//         scalar negation  
NAhE_clause = pre:NAhE_pre post:post_clause { return _word_post(pre, post) }
NAhE_pre = pre:pre_clause word:NAhE spaces? { return _word_pre(word, pre) }
// NAhE_no_SA_handling = pre_clause NAhE post_clause

//         change a selbri into an operator 
NAhU_clause = pre:NAhU_pre post:post_clause { return _word_post(pre, post) }
NAhU_pre = pre:pre_clause word:NAhU spaces? { return _word_pre(word, pre) }
// NAhU_no_SA_handling = pre_clause NAhU post_clause

//         change selbri to operand; inverse of MOI 
NIhE_clause = pre:NIhE_pre post:post_clause { return _word_post(pre, post) }
NIhE_pre = pre:pre_clause word:NIhE spaces? { return _word_pre(word, pre) }
// NIhE_no_SA_handling = pre_clause NIhE post_clause

//         new paragraph; change of subject 
NIhO_clause = sa:sentence_sa* pre:NIhO_pre post:NIhO_post { return _word_post(pre, post, sa) }
NIhO_pre = pre:pre_clause word:NIhO spaces? { return _word_pre(word, pre) }
NIhO_post = su:su_clause* post:post_clause { if (su && su.length) post.su = su; return post }
// NIhO_no_SA_handling = pre_clause NIhO su_clause* post_clause

//         attaches a subordinate clause to a sumti 
NOI_clause = pre:NOI_pre post:post_clause { return _word_post(pre, post) }
NOI_pre = pre:pre_clause word:NOI spaces? { return _word_pre(word, pre) }
// NOI_no_SA_handling = pre_clause NOI post_clause

//         abstraction  
NU_clause = pre:NU_pre post:post_clause { return _word_post(pre, post) }
NU_pre = pre:pre_clause word:NU spaces? { return _word_pre(word, pre) }
// NU_no_SA_handling = pre_clause NU post_clause

//         change operator to selbri; inverse of MOhE 
NUhA_clause = pre:NUhA_pre post:post_clause { return _word_post(pre, post) }
NUhA_pre = pre:pre_clause word:NUhA spaces? { return _word_pre(word, pre) }
// NUhA_no_SA_handling = pre_clause NUhA post_clause

//         marks the start of a termset 
NUhI_clause = pre:NUhI_pre post:post_clause { return _word_post(pre, post) }
NUhI_pre = pre:pre_clause word:NUhI spaces? { return _word_pre(word, pre) }
// NUhI_no_SA_handling = pre_clause NUhI post_clause

//         marks the middle and end of a termset 
NUhU_clause = pre:NUhU_pre post:indicator_post_clause { return _word_post(pre, post) }
NUhU_pre = pre:pre_clause word:NUhU spaces? { return _word_pre(word, pre) }
// NUhU_no_SA_handling = pre_clause NUhU post_clause

//         numbers and numeric punctuation 
PA_clause = pre:PA_pre post:post_clause { return _word_post(pre, post) }
PA_pre = pre:pre_clause word:PA spaces? { return _word_pre(word, pre) }
// PA_no_SA_handling = pre_clause PA post_clause

//         afterthought termset connective prefix 
PEhE_clause = pre:PEhE_pre post:post_clause { return _word_post(pre, post) }
PEhE_pre = pre:pre_clause word:PEhE spaces? { return _word_pre(word, pre) }
// PEhE_no_SA_handling = pre_clause PEhE post_clause

//         forethought (Polish) flag 
PEhO_clause = pre:PEhO_pre post:post_clause { return _word_post(pre, post) }
PEhO_pre = pre:pre_clause word:PEhO spaces? { return _word_pre(word, pre) }
// PEhO_no_SA_handling = pre_clause PEhO post_clause

//         directions in time 
PU_clause = pre:PU_pre post:post_clause { return _word_post(pre, post) }
PU_pre = pre:pre_clause word:PU spaces? { return _word_pre(word, pre) }
// PU_no_SA_handling = pre_clause PU post_clause

//         converts number to extensional tense 
ROI_clause = pre:ROI_pre post:indicator_post_clause { return _word_post(pre, post) }
ROI_pre = pre:pre_clause word:ROI spaces? { return _word_pre(word, pre) }
// ROI_no_SA_handling = pre_clause ROI post_clause

SA_clause = pre:SA_pre post:SA_post { return pre }
SA_pre = pre:pre_clause word:SA spaces? { return _word_pre(word, pre) }
SA_post = spaces?

//         conversions 
SE_clause = pre:SE_pre post:post_clause { return _word_post(pre, post) }
SE_pre = pre:pre_clause word:SE spaces? { return _word_pre(word, pre) }
// SE_no_SA_handling = pre_clause SE post_clause

//         metalinguistic bridi insert marker 
SEI_clause = pre:SEI_pre post:post_clause { return _word_post(pre, post) }
SEI_pre = pre:pre_clause word:SEI spaces? { return _word_pre(word, pre) }
// SEI_no_SA_handling = pre_clause SEI post_clause

//         metalinguistic bridi end marker 
SEhU_clause = pre:SEhU_pre post:indicator_post_clause { return _word_post(pre, post) }
SEhU_pre = pre:pre_clause word:SEhU spaces? { return _word_pre(word, pre) }
// SEhU_no_SA_handling = pre_clause SEhU post_clause

//         metalinguistic single word eraser 
SI_clause = spaces? word:SI spaces? { return word }

//         EXP: bridi relative clause
SOI_clause = pre:SOI_pre post:post_clause { return _word_post(pre, post) } 
SOI_pre = pre:pre_clause word:SOI spaces? { return _word_pre(word, pre) }
// SOI_no_SA_handling = pre_clause SOI post_clause

//         metalinguistic eraser of the entire text 
SU_clause = pre:SU_pre post:post_clause { return _word_post(pre, post) }
SU_pre = pre:pre_clause word:SU spaces? { return _word_pre(word, pre) }

//         closing gap for MEX constructs 
TEhU_clause = pre:TEhU_pre post:post_clause { return _word_post(pre, post) }
TEhU_pre = pre:pre_clause word:TEhU spaces? { return _word_pre(word, pre) }
// TEhU_no_SA_handling = pre_clause TEhU post_clause

//         start compound lerfu 
TEI_clause = pre:TEI_pre post:post_clause { return _word_post(pre, post) }
TEI_pre = pre:pre_clause word:TEI spaces? { return _word_pre(word, pre) }
// TEI_no_SA_handling = pre_clause TEI post_clause

//         left discursive parenthesis 
TO_clause = pre:TO_pre post:indicator_post_clause { return _word_post(pre, post) }
TO_pre = pre:pre_clause word:TO spaces? { return _word_pre(word, pre) }
// TO_no_SA_handling = pre_clause TO post_clause

//         right discursive parenthesis 
TOI_clause = pre:TOI_pre post:indicator_post_clause { return _word_post(pre, post) }
TOI_pre = pre:pre_clause word:TOI spaces? { return _word_pre(word, pre) }
// TOI_no_SA_handling = pre_clause TOI post_clause

//         multiple utterance scope mark 
TUhE_clause = pre:TUhE_pre post:TUhE_post { if (post && post.length) pre.su = post; return _word_post(pre, post) }
TUhE_pre = pre:pre_clause word:TUhE spaces? { return _word_pre(word, pre) }
TUhE_post = su:su_clause* spaces? { return su }
// TUhE_no_SA_handling = pre_clause TUhE su_clause* post_clause

//         multiple utterance end scope mark 
TUhU_clause = pre:TUhU_pre post:indicator_post_clause { return _word_post(pre, post) }
TUhU_pre = pre:pre_clause word:TUhU spaces? { return _word_pre(word, pre) }
// TUhU_no_SA_handling = pre_clause TUhU post_clause


//         attitudinals, observationals, discursives 
UI_clause = pre:UI_pre post:indicator_post_clause { return _word_post(pre, post) }
UI_pre = pre:pre_clause word:UI spaces? { return _word_pre(word, pre) }
// UI_no_SA_handling = pre_clause UI post_clause

//         end simple bridi or bridi_tail 
VAU_clause = pre:VAU_pre post:indicator_post_clause { return _word_post(pre, post) }
VAU_pre = pre:pre_clause word:VAU spaces? { return _word_pre(word, pre) }
// VAU_no_SA_handling = pre_clause VAU post_clause

//         left MEX bracket 
VEI_clause = pre:VEI_pre post:post_clause { return _word_post(pre, post) }
VEI_pre = pre:pre_clause word:VEI spaces? { return _word_pre(word, pre) }
// VEI_no_SA_handling = pre_clause VEI post_clause

//         right MEX bracket 
VEhO_clause = pre:VEhO_pre post:indicator_post_clause { return _word_post(pre, post) }
VEhO_pre = pre:pre_clause word:VEhO spaces? { return _word_pre(word, pre) }
// VEhO_no_SA_handling = pre_clause VEhO post_clause

//         MEX operator 
VUhU_clause = pre:VUhU_pre post:post_clause { return _word_post(pre, post) }
VUhU_pre = pre:pre_clause word:VUhU spaces? { return _word_pre(word, pre) }
// VUhU_no_SA_handling = pre_clause VUhU post_clause

// glue between logically connected sumti and relative clauses 
VUhO_clause = pre:VUhO_pre post:indicator_post_clause { return _word_post(pre, post) }
VUhO_pre = pre:pre_clause word:VUhO spaces? { return _word_pre(word, pre) }
// VUhO_no_SA_handling = pre_clause VUhO post_clause

//         subscripting operator 
XI_clause = pre:XI_pre post:post_clause { return _word_post(pre, post) }
XI_pre = pre:pre_clause word:XI spaces? { return _word_pre(word, pre) }
// XI_no_SA_handling = pre_clause XI post_clause


//         hesitation 
// Very very special case.  Handled in the morphology section.
// Y_clause = spaces? Y spaces?

//         lujvo glue 
ZEI_clause = pre:ZEI_pre post:ZEI_post { return pre }
// ZEI_clause_no_SA = ZEI_pre_no_SA ZEI ZEI_post
ZEI_pre = pre:pre_clause word:ZEI spaces? { return _word_pre(word, pre) }
// ZEI_pre_no_SA = pre_clause
ZEI_post = spaces?
// ZEI_no_SA_handling = pre_clause ZEI post_clause

//         single word metalinguistic quote marker 
ZO_clause = pre:ZO_pre post:post_clause { return _word_post(pre, post) }
ZO_pre = pre:pre_clause word:ZO spaces? quoted:any_word spaces? {
  return _word_pre(_quote(word, quoted), pre)
}
// ZO_no_SA_handling = pre_clause ZO spaces? any_word spaces?

//         delimited quote marker 
ZOI_clause = pre:ZOI_pre post:post_clause { return _word_post(pre, post) }
//// EXP-EDIT: ZOI fix
ZOI_pre = pre:pre_clause word:ZOI spaces? open:zoi_open spaces? quoted:zoi_word* close:zoi_close dot:(&(post_word &. !nucleus !cmevla) { return "." })? spaces? {
  word.subsumed = [open, close];
  word.quoted = quoted || [];
  word.quoted.word = word.quoted.join(" ");
  word.single_word = word.word;
  var open_word = open.word.match(/\.$/) ? open.word : open.word + ".";
  var close_word = _empty(dot) ? close.word + dot : close.word;
  if (close_word[0] != ".") close_word = "." + close_word;
  if (options.format == "text")
    word.word = word.word + " «" + open_word + " " + word.quoted.word + " " + close_word + "»";
  else
    word.word = "[" + word.word + " " + open_word + " " + word.quoted.word + " " + close_word + "]";
  return _word_pre(word, pre)
}
// ZOI_no_SA_handling = pre_clause ZOI spaces? zoi_open zoi_word* zoi_close spaces?

//         prenex terminator (not elidable) 
ZOhU_clause = pre:ZOhU_pre post:indicator_post_clause { return _word_post(pre, post) }
ZOhU_pre = pre:pre_clause word:ZOhU spaces? { return _word_pre(word, pre) }
// ZOhU_no_SA_handling = pre_clause ZOhU post_clause

// [EXPERIMENTAL]        single foreign word quote marker 
ZOhOI_clause = pre:ZOhOI_pre post:post_clause { return _word_post(pre, post) }
ZOhOI_pre = pre:pre_clause word:ZOhOI spaces? quoted:zohoi_word spaces? {
  return _word_pre(_quote(word, quoted), pre)
}

MEhOI_clause = pre:MEhOI_pre post:post_clause { return _word_post(pre, post) }
MEhOI_pre = pre:pre_clause word:MEhOI spaces? quoted:zohoi_word spaces? {
  word.quoted = quoted;
  return _word_pre(_quote(word, quoted), pre)
}

GOhOI_clause = pre:GOhOI_pre post:post_clause { return _word_post(pre, post) }
GOhOI_pre = pre:pre_clause word:GOhOI spaces? quoted:any_word spaces? {
  word.quoted = quoted;
  return _word_pre(_quote(word, quoted), pre)
}

NOhOI_clause = pre:NOhOI_pre post:post_clause { return _word_post(pre, post) }
NOhOI_pre = pre:pre_clause word:NOhOI spaces? { return _word_pre(word, pre) }

KUhOI_clause = pre:KUhOI_pre post:indicator_post_clause { return _word_post(pre, post) }
KUhOI_pre = pre:pre_clause word:KUhOI spaces? { return _word_pre(word, pre) }

LOhOI_clause = pre:LOhOI_pre post:post_clause { return _word_post(pre, post) }
LOhOI_pre = pre:pre_clause word:LOhOI spaces? { return _word_pre(word, pre) }

KUhAU_clause = pre:KUhAU_pre post:indicator_post_clause { return _word_post(pre, post) }
KUhAU_pre = pre:pre_clause word:KUhAU spaces? { return _word_pre(word, pre) }

ga_clause = pre:ga_pre post:post_clause { return _word_post(pre, post) }
ga_pre = pre:pre_clause word:ga_word spaces? { return _word_pre(word, pre) }
ga_word = &cmavo expr:( g a ) &post_word {return _word("ga_word", expr);}

gu_clause = pre:gu_pre post:post_clause { return _word_post(pre, post) }
gu_pre = pre:pre_clause word:gu_word spaces? { return _word_pre(word, pre) }
gu_word = &cmavo expr:( g u ) &post_word {return _word("gu_word", expr);}


// ___ MORPHOLOGY ___

//// EXP-MODIF: brivla/cmevla merge
BRIVLA = &{return !options.rafcau} brivo:(gismu / lujvo / fuhivla / cmevla) { return _brivla(brivo) } 
  / &{return options.rafcau} brivo:(brivla_rafcau / cmevla) { return _brivla(brivo) }
//// EXP-DEL: LA, for brivla/cmevla merge
// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
CMAVO = expr:(BAhE / BE / BEI / BEhO / BO / BOI / BU / BY / CAI / CEI / CEhE / CO / COI / CU / DOI / DOhU / FA / FAhO / FEhE / FEhU / FIhO / FOI / FUhA / FUhE / FUhO / GA / GAhO / GEhU / GI / GIhA / GOI / GOhA / GUhA / I / JAI / JOhI / JOI / KE / KEhE / KEI / KOhA / KU / KUhE / KUhO / LAU / LE / LEhAI / LEhU / LI / LIhU / LOhAI / LOhO / LOhU / LU / LUhU / MAhO / MAI / ME / MEhU / MOhE / MOI / NA / NAI / NAhE / NAhU / NIhE / NIhO / NOI / NU / NUhA / NUhI / NUhU / PA / PEhE / PEhO / PU / ROI / SA / SE / SEI / SEhU / SI / SOI / SU / TEhU / TEI / TO / TOI / TUhE / TUhU / UI / VAU / VEI / VEhO / VUhU / VUhO / XI / ZEI / ZO / ZOI / ZOhU / (c:cmavo { return _word("?", c) })) {return expr;}

// This is a Parsing Expression Grammar for the morphology of Lojban.
// See http://www.pdos.lcs.mit.edu/~baford/packrat/
//
// All rules have the form
//
// name = peg_expression
//
// which means that the grammatical construct "name" is parsed using
// "peg_expression".
//
// 1) Concatenation is expressed by juxtaposition with no operator symbol.
// 2) / represents *ORDERED* alternation (choice). If the first
// option succeeds, the others will never be checked.
// 3) ? indicates that the element to the left is optional.
// 4) * represents optional repetition of the construct to the left.
// 5) + represents one_or_more repetition of the construct to the left.
// 6) () serves to indicate the grouping of the other operators.
// 7) & indicates that the element to the right must follow (but the
// marked element itself does not absorb anything).
// 8) ! indicates that the element to the right must not follow (the
// marked element itself does not absorb anything).
// 9) . represents any character.
// 10) ' ' or " " represents a literal string.
// 11) [] represents a character class.
//
// Repetitions grab as much as they can.
//
//
// ___ GRAMMAR ___
// This grammar classifies words by their morphological class (cmevla,
// gismu, lujvo, fuhivla, cmavo, and non_lojban_word).
//
//The final section sorts cmavo into grammatical classes (A, BAI, BAhE, ..., ZOhU).
//
// mi'e ((xorxes))

//___________________________________________________________________

// words = expr:(pause? (word pause?)*) { return _join(expr); }

// word = expr:lojban_word / non_lojban_word { return expr; }

// lojban_word = expr:(cmevla / cmavo / brivla) { return expr; }
lojban_word = dot:pre_dot expr:(CMAVO / BRIVLA) {
  if (_empty(dot)) {
    expr = _duplicate_less_evil(expr); 
    expr.word = dot + expr.word;
  }
  return expr;
}

any_word = expr:lojban_word spaces? { return expr; }

//// EXP-MODIF: ZOI-fix
zoi_open = w:lojban_word { return _zoi_assign_delim(w); }
zoi_word = expr:( w:(non_space+) spaces &{ return (! _zoi_check_quote(w)); } ) { return _join(expr) }
zoi_close = w:any_word &{ return (_zoi_check_delim(w)); } { return w }

//// EXP-MODIF: ZOhOI/MEhOI implementation
zohoi_word = expr:non_space+ { return _join(expr) } 

//___________________________________________________________________

//cmevla = expr:(jbocme / zifcme) dot:(!(post_word nucleus) {return "."})? { return _join(expr) + (dot || ""); }
cmevla = expr:zifcme dot:(!(post_word (nucleus / cmevla)) {return "."})? { return _join(expr) + (dot || ""); }

zifcme = (!h (any_syllable / nucleus / glide / h / consonant !pause / digit)* consonant &pause)

// jbocme = (&zifcme (any_syllable / digit)* &pause)

//cmevla = !h cmevla_syllable* &consonant coda? consonantal_syllable* onset &pause

//cmevla_syllable = !doi_la_lai_lahi coda? consonantal_syllable* onset nucleus / digit

//doi_la_lai_lahi = (d oi / l a (h? i)?) !h !nucleus

//___________________________________________________________________

cmavo = expr:(!cmevla !CVCy_lujvo cmavo_form &post_word) { return _join(expr); }

//// EXP-MODIF: logbanu lujvo
CVCy_lujvo = expr:(CVC_rafsi y h? (initial_rafsi / logbanu_rafsi)* brivla_core / stressed_CVC_rafsi y short_final_rafsi) { return _join(expr); }

cmavo_form = expr:(!h !cluster onset (nucleus h)* (!stressed nucleus / nucleus !cluster) / y+ / digit) { return _join(expr); }

//___________________________________________________________________

//// EXP-MODIF: logbanu lujvo
brivla = !cmavo !slihykru expr:( (init:(!any_fuhivla_rafsi yless:y_less_rafsi !any_fuhivla_rafsi { return yless })* fin:((extended_rafsi / y_rafsi) (initial_rafsi / logbanu_rafsi)*)? { return fin ? init.concat(fin[0]).concat(fin[1]) : init }) brivla_core) { return expr[0] ? expr[0].concat(expr[1]) : expr[1]; }

brivla_rafcau = !cmavo !slihykru !slinkuhi !h expr:((!stressed syllable !stress any_unstressed_syllable*)? stressed_syllable medial_syllable* unstressed_syllable) { return _join(expr) }

brivla_core = expr:(fuhivla / gismu / CVV_final_rafsi / stressed_initial_rafsi short_final_rafsi) { return [].concat(expr) }

//// EXP-MODIF: logbanu lujvo
stressed_initial_rafsi = expr:(stressed_extended_rafsi / stressed_y_rafsi / stressed_y_less_rafsi / stressed_logbanu_rafsi) { return _join(expr); }

initial_rafsi = expr:(extended_rafsi / y_rafsi / !any_fuhivla_rafsi y_less_rafsi !any_fuhivla_rafsi) { return _join(expr); }

//___________________________________________________________________

any_fuhivla_rafsi = expr:(fuhivla / fuhivla_rafsi / stressed_fuhivla_rafsi) { return _join(expr); }

fuhivla = expr:(fuhivla_head stressed_syllable consonantal_syllable* final_syllable) { return _join(expr); }

stressed_extended_rafsi = expr:(stressed_hy_rafsi / stressed_fuhivla_rafsi) { return _join(expr); }

extended_rafsi = expr:(hy_rafsi / fuhivla_rafsi) { return _join(expr); }

stressed_fuhivla_rafsi = expr:(fuhivla_head stressed_syllable consonantal_syllable* onset y) { return _join(expr); }

fuhivla_rafsi = expr:(&unstressed_syllable fuhivla_head onset y h?) { return _join(expr); }

//// EXP-ADD: logbanu lujvo
stressed_logbanu_rafsi = expr:(consonant stressed_vowel !coda !(h vowel) (h y h? / &short_final_rafsi)) { return _join(expr); }
logbanu_rafsi = expr:(!fuhivla consonant unstressed_vowel !coda !CCV_rafsi !stressed_CCV_rafsi !(h vowel) (h y h? / &logbanu_tail)) { return _join(expr); }
logbanu_tail = any_fuhivla_rafsi? (logbanu_tail_1+ rafsi_string / logbanu_tail_1*) &post_word
logbanu_tail_1 = gismu &post_word / fuhivla &post_word / fuhivla_rafsi / stressed_fuhivla_rafsi / y_rafsi / stressed_y_rafsi / CVV_rafsi (h y h?) / stressed_CVV_rafsi (h y)? / CVC_rafsi / stressed_CVC_rafsi / logbanu_rafsi / stressed_logbanu_rafsi

fuhivla_head = expr:(!lujvly brivla_head) { return _join(expr); }

brivla_head = expr:(!cmavo !slinkuhi !h &onset unstressed_syllable*) { return _join(expr); }

slinkuhi = expr:(!rafsi_string consonant rafsi_string) { return _join(expr); }
slinkuhi_ignore = slinkuhi .+

rafsi_string = expr:(y_less_rafsi* rafsi_string_1) { return _join(expr); }
rafsi_string_1 = gismu / CVV_final_rafsi / stressed_y_less_rafsi short_final_rafsi_nonlogbanu / y_rafsi / stressed_y_rafsi / hy_rafsi &onset / stressed_hy_rafsi &onset

lujvly = expr:((!lujvly_1 y_less_rafsi)* (lujvly_1 / rafsi_string_1))
lujvly_1 = (stressed_y_less_rafsi / y_less_rafsi) initial_pair y !coda

slihykru = (CCV_rafsi / stressed_CCV_rafsi) h y onset

//___________________________________________________________________

gismu = expr:((initial_pair stressed_vowel / consonant stressed_vowel consonant) &final_syllable consonant vowel &post_word) { return _join(expr); }

CVV_final_rafsi = expr:(consonant stressed_vowel h &final_syllable vowel &post_word) { return _join(expr); }

//// EXP-MODIF: logbanu lujvo
short_final_rafsi = expr:(&final_syllable (consonant diphthong / consonant vowel / initial_pair vowel) &post_word) { return _join(expr); }
short_final_rafsi_nonlogbanu = expr:(&final_syllable (consonant diphthong / initial_pair vowel) &post_word) { return _join(expr); }

//// EXP-MODIF: CyC syllables in fuhivla
stressed_y_rafsi = expr:((stressed_long_rafsi / stressed_CVC_rafsi) y !coda) { return _join(expr); }

stressed_y_less_rafsi = expr:(stressed_CVC_rafsi !y / stressed_CCV_rafsi / stressed_CVV_rafsi) { return _join(expr); }

//// EXP-MODIF: CyC syllables in fuhivla
stressed_long_rafsi = expr:(initial_pair stressed_vowel !consonantal_syllable consonant / consonant stressed_vowel consonant !consonantal_syllable consonant) { return _join(expr); }

//// EXP-MODIF: logbanu lujvo
//// EXP-MODIF: CyC syllables in fuhivla
stressed_CVC_rafsi = expr:(consonant stressed_vowel !short_final_rafsi !CVV_final_rafsi !consonantal_syllable consonant) { return _join(expr); }

stressed_CCV_rafsi = expr:(initial_pair stressed_vowel) { return _join(expr); }

stressed_CVV_rafsi = expr:(consonant (unstressed_vowel h stressed_vowel / stressed_diphthong) r_hyphen?) { return _join(expr); }

//// EXP-MODIF: CyC syllables in fuhivla
y_rafsi = expr:((long_rafsi / CVC_rafsi) y !coda h?) { return _join(expr); }

y_less_rafsi = expr:(!y_rafsi !stressed_y_rafsi !hy_rafsi !stressed_hy_rafsi (CVC_rafsi / CCV_rafsi / CVV_rafsi) !h) { return _join(expr); }

hy_rafsi = expr:((long_rafsi unstressed_vowel / CCV_rafsi / CVV_rafsi) !consonantal_syllable h y h?) { return _join(expr); }

stressed_hy_rafsi = expr:((long_rafsi stressed_vowel / stressed_CCV_rafsi / stressed_CVV_rafsi) !consonantal_syllable h y h?) { return _join(expr); }

//// EXP-MODIF: CyC syllables in fuhivla
long_rafsi = expr:(initial_pair unstressed_vowel !consonantal_syllable consonant / consonant unstressed_vowel consonant !consonantal_syllable consonant) { return _join(expr); }

//// EXP-MODIF: logbanu lujvo
//// EXP-MODIF: CyC syllables in fuhivla
CVC_rafsi = expr:(consonant unstressed_vowel !logbanu_rafsi !stressed_logbanu_rafsi !CVV_rafsi !stressed_CVV_rafsi !CVV_final_rafsi !consonantal_syllable consonant) { return _join(expr); }

CCV_rafsi = expr:(initial_pair unstressed_vowel) { return _join(expr); }

CVV_rafsi = expr:(consonant (unstressed_vowel h unstressed_vowel / unstressed_diphthong) r_hyphen?) { return _join(expr); }

r_hyphen = expr:(r &consonant / n &r) { return _join(expr); }

//___________________________________________________________________

final_syllable = expr:(onset !y !stressed nucleus !cmevla &post_word) {return _join(expr);}

stressed_syllable = expr:(&stressed syllable / syllable &stress)
  {return _join(expr).replace(/[aeiou]/, function (a) { return _stressed_vowels[a] });}

stressed_diphthong = expr:(&stressed diphthong / diphthong &stress) {return {ai: "ài", ei: "èi", oi: "òi", au: "àu"}[_join(expr)];}

stressed_vowel = expr:(&stressed vowel / vowel &stress) {return _stressed_vowels[_join(expr)];}

//// EXP-MODIF: CyC syllables in fuhivla
unstressed_syllable = expr:(consonantal_syllable / !stressed syllable !stress) {return _join(expr);}

unstressed_diphthong = expr:(!stressed diphthong !stress) {return _join(expr);}

unstressed_vowel = expr:(!stressed vowel !stress) {return _join(expr);}

//// FIX: Xorxes' fix for fu'ivla rafsi stress
//// EXP-MODIF: CyC syllables in fuhivla
stress = expr:((any_onset y coda / consonant / glide)* h? y? syllable pause) {return _join(expr);}

stressed = expr:(onset comma* [AEIOU]) {return _join(expr);}

//// EXP-MODIF: CyC syllables in fuhivla
any_syllable = expr:(medial_syllable / syllable) {return _join(expr);}
any_unstressed_syllable = expr:(medial_syllable / !stressed onset !y nucleus coda? !stress) { return _join(expr) }
medial_syllable = expr:(consonantal_syllable / onset y) { return _join(expr) }

syllable = expr:(onset !y nucleus coda?) {return _join(expr);}

//// FIX: preventing {bla'ypre} from being a valid lujvo
//// EXP-MODIF: CyC syllables in fuhivla
consonantal_syllable = expr:(any_onset y coda / consonant &syllabic coda) //{return _join(expr);}
 {var foo = _join(expr); if (foo.length == 2) return foo[0] + "y" + foo[1]; return foo }

//// EXP-MODIF: CyC syllables in fuhivla
coda = expr:(!any_syllable consonant &any_syllable) {return _join(expr);}

//// EXP-MODIF: CyC syllables in fuhivla
any_onset = expr:(h / glide / initial) {return _join(expr);}
onset = !consonantal_syllable expr:(any_onset) {return expr;}

nucleus = expr:(vowel / diphthong / y !nucleus) {return _join(expr);}

//_________________________________________________________________

glide = expr:(i { return "ĭ" } / u { return "ŭ" }) &nucleus !glide {return expr;}

diphthong = expr:(a u !u (&(post_word !cmevla u nucleus) {return "."})? / (a i / e i / o i) !i (&(post_word !cmevla i nucleus) {return "."})?) !nucleus {return _join(expr);}

vowel = expr:(a / e / i / o / u) !nucleus {return expr;}

a = comma* [aA] {return "a";}
ai = &(a i) expr:diphthong {return expr;}
au = &(a u) expr:diphthong {return expr;}

e = comma* [eE] {return "e";}
ei = &(e i) expr:diphthong {return expr;}

i = comma* [iI] expr:(&nucleus {return "ĭ"})? {return expr || "i";}

o = comma* [oO] {return "o";}
oi = &(o i) expr:diphthong {return expr;}

u = comma* [uU] expr:(&nucleus {return "ŭ"})? {return expr || "u";}

y = comma* [yY] !(!y nucleus) {return "y";}


//___________________________________________________________________

cluster = expr:(consonant consonant+) {return _join(expr);}

initial_pair = expr:(&initial consonant consonant !consonant) {return _join(expr);}

initial = expr:(affricate / sibilant? other? liquid?) !consonant !glide {return _join(expr);}

affricate = expr:(t c / t s / d j / d z) {return _join(expr);}

liquid = expr:(l / r) {return _join(expr);}

other = expr:(p / t !l / k / f / x / b / d !l / g / v / m / n !liquid) {return _join(expr);}

sibilant = expr:(c / s !x / (j / z) !n !liquid) {return _join(expr); }

consonant = voiced / unvoiced / syllabic

syllabic = l / m / n / r

voiced = b / d / g / j / v / z

unvoiced = c / f / k / p / s / t / x

l = comma* [lL] !h !l {return "l";}

m = comma* [mM] !h !glide !m {return "m";}

n = comma* [nN] !h !n !affricate  {return "n";}

r = comma* [rR] !h !r {return "r";}

b = comma* [bB] !h !glide !b !unvoiced {return "b";}

d = comma* [dD] !h !glide !d !unvoiced {return "d";}

g = comma* [gG] !h !g !unvoiced {return "g";}

v = comma* [vV] !h !glide !v !unvoiced {return "v";}

j = comma* [jJ] !h !glide !j !z !unvoiced {return "j";}

z = comma* [zZ] !h !glide !z !j !unvoiced {return "z";}

s = comma* [sS] !h !glide !s !c !voiced {return "s";}

c = comma* [cC] !h !glide !c !s !voiced {return "c";}

x = comma* [xX] !h !glide !x !voiced {return "x";}

k = comma* [kK] !h !k !x !voiced {return "k";}

f = comma* [fF] !h !glide !f !voiced {return "f";}

p = comma* [pP] !h !glide !p !voiced {return "p";}

t = comma* [tT] !h !glide !t !voiced {return "t";}

h = comma* ['hH] &nucleus {return "'";}

//___________________________________________________________________

digit = expr:(comma* [0123456789] !h !nucleus) {return _join(expr);}

post_word = expr:(pause / !nucleus lojban_word)  {return _join(expr);}

pause = expr:(comma* space_char+ / EOF)  {return _join(expr);}

EOF = expr:(comma* !.)  {return _join(expr);}

comma = [,] {return "";}

non_lojban_word = expr:(!lojban_word non_space+)  {return _join(expr);}

non_space = expr:(!space_char .) {return _join(expr);}

//Unicode_style and escaped chars not compatible with cl_peg
space_char = [.\t\n\r?!\u0020] {return "";}

// space_char = [.?! ] / space_char1 / space_char2 
// space_char1 = '    '
// space_char2 = ''

//___________________________________________________________________

spaces = expr:(!Y initial_spaces)  {return _join(expr);}

initial_spaces = expr:((comma* space_char / !ybu Y)+ EOF? / EOF)  {return _join(expr);}

ybu = expr:(Y space_char* BU)  {return "ybu";}

lujvo = !gismu !fuhivla expr:brivla  {return expr;}

//___________________________________________________________________

BAhE = &cmavo expr:( b a h ei / z a h ei / b a h e / z a h e ) &post_word {return _word("BAhE", expr);}

BE = &cmavo expr:( b e ) &post_word  {return _word("BE", expr);}

BEI = &cmavo expr:( b ei ) &post_word {return _word("BEI", expr);}

BEhO = &cmavo expr:( b e h o ) &post_word {return _word("BEhO", expr);}

BO = &cmavo expr:( b o ) &post_word  {return _word("BO", expr);}

BOI = &cmavo expr:( b oi ) &post_word {return _word("BOI", expr);}

BU = &cmavo expr:( &{return options.buhu == "bu"} b u h u / &{return options.buhu != "bu"} b u ) &post_word {return _word(options.buhu == "bu" ? "BUhU" : "BU", expr);}

//// EXP-MODIF: Adding .uy and .iy (Selpa'i)
BY = &cmavo dot:(&(lermaho !EOF !cmevla !nucleus !(&onset lermaho)) {return "."})? expr:(ybu / j o h o / r u h o / g e h o / j e h o / l o h a / n a h a / &{return !options.diftogoteha} s e h e / t o h a / g a h e / y h y / a h y / e h y / i h y / o h y / u h y / b y / c y / d y / f y / g y / j y / k y / l y / m y / n y / p y / r y / s y / t y / v y / x y / z y / u y / i y ) &post_word {return _word("BY", _join(expr) + (dot || ""));}
lermaho = !ybu &cmavo onset? (nucleus h)* y (pause / &post_word)

CAI = &cmavo expr:( p ei / c ai / c u h i / s ai / r u h e / m a u h i / d a u h i / m e h ai ) &post_word {return _word("CAI", expr);}

CEI = &cmavo expr:( c ei ) &post_word {return _word("CEI", expr);}

CEhE = &cmavo expr:( c e h e ) &post_word {return _word("CEhE", expr);}

CO = &cmavo expr:( c o ) &post_word {return _word("CO", expr);}

//// EXP-ADD: di'ai, co'oi, ki'ai, sa'ei
COI = &cmavo expr:( d i h ai / a h oi / c o h oi / &{return options.diftogoteha} d i h o / j u h i / c oi / f i h i / t a h a / m u h o / f e h o / c o h o / p e h u / k e h o / n u h e / r e h i / b e h e / j e h e / m i h e / k i h e / v i h o ) &post_word {return _word("COI", expr);}

CU = &cmavo expr:( c u ) &post_word {return _word("CU", expr);}

//// EXP-ADD: da'oi
DOI = &cmavo expr:( j o h au / d a h oi / k i h ai / s a h ei / d oi ) &post_word {return _word("DOI", expr);}

DOhU = &cmavo expr:( d o h u ) &post_word {return _word("DOhU", expr);}

FA = &cmavo expr:( f ai / f a / f e / f o / f u / f i h a / f i ) &post_word {return _word("FA", expr);}

FAhO = &cmavo expr:( f a h o ) &post_word {return _word("FAhO", expr);}

FEhE = &cmavo expr:( f e h e / m o h i ) &post_word {return _word("FEhE", expr);}

FEhU = &cmavo expr:( f e h u ) &post_word {return _word("FEhU", expr);}

FIhO = &cmavo expr:( f i h o ) &post_word {return _word("FIhO", expr);}

FOI = &cmavo expr:( f oi ) &post_word {return _word("FOI", expr);}

FUhA = &cmavo expr:( f u h a ) &post_word {return _word("FUhA", expr);}

FUhE = &cmavo expr:( f u h e ) &post_word {return _word("FUhE", expr);}

FUhO = &cmavo expr:( f u h o ) &post_word {return _word("FUhO", expr);}

GA = &cmavo expr:( g e h i / g e / g o / g a / g u ) &post_word {return _word("GA", expr);}

GAhO = &cmavo expr:( k e h i / g a h o ) &post_word {return _word("GAhO", expr);}

GEhU = &cmavo expr:( g e h u ) &post_word {return _word("GEhU", expr);}

GI = &cmavo expr:( g i ) &post_word {return _word("GI", expr);}

GIhA = &cmavo expr:( g i h e / g i h i / g i h o / g i h a / g i h u ) &post_word {return _word("GIhA", expr);}

GOI = &cmavo expr:( n o h u / n e / g oi / p o h u / p e / &{return !options.po} (p o h e / p o) ) &post_word {return _word("GOI", expr);}

GOhA = &cmavo expr:( &{return options.du && !options.dujoi} d u h u / m o / n ei / g o h u / g o h o / g o h i / n o h a / g o h e / g o h a / &{return !options.du && !options.dujoi} d u / b u h a / b u h e / b u h i / c o h e ) &post_word {return _word("GOhA", expr);} 

GUhA = &cmavo expr:( g u h e / g u h i / g u h o / g u h a / g u h u ) &post_word {return _word("GUhA", expr);}

I = &cmavo expr:( i ) &post_word {return _word("I", expr);}

JAI = &cmavo expr:( j ai ) &post_word {return _word("JAI", expr);}

JOhI = &cmavo expr:( j o h i ) &post_word {return _word("JOhI", expr);}

JOI = &cmavo expr:( b i h e / m i h i / b i h o / b i h i / z i h e / f a h u / p i h u / j oi / c e h o / &{return options.ckt} c e h u / &{return !options.ckt} c e / j o h u / k u h a / j o h e / j u h e / j e h i / &{return options.dujoi && options.du} d u h u / j e / j o / j a / j u / j i / &{return options.dujoi && !options.du} d u / a / e / o / u ) &post_word {return _word("JOI", expr);}

KE = &cmavo expr:( k e / p i h ai ) &post_word {return _word("KE", expr);}

KEhE = &cmavo expr:( k e h e ) &post_word {return _word("KEhE", expr);}

KEI = &cmavo expr:( k ei ) &post_word {return _word("KEI", expr);}

//// EXP-ADD: xai
KOhA = &cmavo expr:( &{return options.diftogoteha} s e h e / d a h u / d a h e / d i h u / d i h e / d e h u / d e h e / d ei / d o h i / m i h o / m i h ai / m a h a / m i h a / d o h o / k o h a / f o h u / k o h e / k o h i / k o h o / k o h u / f o h a / f o h e / f o h i / f o h o / v o h a / v o h e / v o h i / v o h o / v o h u / &{return options.lau} l au / r u / r i / r a / t a / t u / t i / z i h o / &{return !options.ckt} k e h a / m a / z u h i / z o h e / &{return !options.ckt} c e h u / d a / d e / d i / k o / m i / d o / x ai / &{return options.ckt} c e / &{return options.ckt} k i ) &post_word { return _word("KOhA", expr);}

KU = &cmavo expr:( k u ) &post_word {return _word("KU", expr);}

KUhE = &cmavo expr:( k u h e ) &post_word {return _word("KUhE", expr);}

KUhO = &cmavo expr:( k u h o ) &post_word {return _word("KUhO", expr);}

//// EXP-DELETION: brivla/cmevla merge
// LA = &cmavo expr:( l ai / l a h i / l a ) &post_word { return _word("LA", expr); }

LAU = &cmavo expr:( c e h a / &{return options.ckt} t u h a / &{return !options.lau} l au / &{return options.buhu != "zai"} z ai / &{return !options.ckt} t au ) &post_word {return _word(options.lau ? "CEhA" : "LAU", expr);}

LAhE = &cmavo expr:( z o h ei / &{return !options.ckt} t u h a / l u h a / l u h o / l a h e / v u h i / l u h i / l u h e / &{return options.ckt} t au ) &post_word {return _word("LAhE", expr);}

//// EXP-MODIF: brivla/cmevla merge + add of me'ei
LE = &cmavo expr:( r i h oi / m e h ei / l ei / l oi / l e h i / l o h i / l e h e / l o h e / l o / l e / l ai / l a h i / l a ) &post_word { return _word("LE", expr);}

// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
LEhAI = &cmavo expr:( l e h ai ) &post_word {return _word("LEhAI", expr);}

LEhU = &cmavo expr:( l e h u ) &post_word {return _word("LEhU", expr);}

LI = &cmavo expr:( l i h ai / m e h o / l i ) &post_word {return _word("LI", expr);}

LIhU = &cmavo expr:( l i h u ) &post_word {return _word("LIhU", expr);}

// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
LOhAI = &cmavo expr:( l o h ai / s a h ai ) &post_word {return _word("LOhAI", expr);}

LOhO = &cmavo expr:( l o h o ) &post_word {return _word("LOhO", expr);}

LOhU = &cmavo expr:( l o h u ) &post_word {return _word("LOhU", expr);}

LU = &cmavo expr:( l a h au / l u ) &post_word {return _word("LU", expr);}

LUhU = &cmavo expr:( l u h u ) &post_word {return _word("LUhU", expr);}

MAhO = &cmavo expr:( m a h o ) &post_word {return _word("MAhO", expr);}

MAI = &cmavo expr:( m o h o / m ai ) &post_word {return _word("MAI", expr);}

//// EXP-ADD: me'au
ME = &cmavo expr:(m e h au / m e) &post_word {return _word("ME", expr);}

MEhU = &cmavo expr:( m e h u ) &post_word {return _word("MEhU", expr);}

MOhE = &cmavo expr:( m o h e ) &post_word {return _word("MOhE", expr);}

MEIhE = &cmavo expr:( m e i h e ) &post_word {return _word("MEIhE", expr);}

MEIhO = &cmavo expr:( m e i h o ) &post_word {return _word("MEIhO", expr);}

MOI = &cmavo expr:( m o i h o / m ei / m oi / s i h e / c u h o / v a h e ) &post_word {return _word("MOI", expr);}

MUhOI = &cmavo expr:( m u h oi ) &post_word {return _word("MUhOI", expr);}

NA = &cmavo expr:( j a h a / n a ) &post_word {return _word("NA", expr);}

//// EXP-ADD: ja'ai
NAI = &cmavo expr:( n ai / j a h ai ) &post_word {return _word("NAI", expr);}

//// EXP-ADD: na'ei
NAhE = &cmavo expr:( j e h ai / n a h ei / t o h e / j e h a / n a h e / n o h e ) &post_word {return _word("NAhE", expr);}

NAhU = &cmavo expr:( n a h u ) &post_word {return _word("NAhU", expr);}

NIhE = &cmavo expr:( n i h e ) &post_word {return _word("NIhE", expr);}

NIhO = &cmavo expr:( n i h o / n o h i ) &post_word {return _word("NIhO", expr);}

NOI = &cmavo expr:( n oi / &{return !options.voi} v oi / p oi ) &post_word {return _word("NOI", expr);}

//// EXP-ADD: poi'i, kai'u
NU = &cmavo expr:( p o i h i / k a i h u / n i / &{return !options.du} d u h u / s i h o / n u / l i h i / k a / j ei / s u h u / z u h o / m u h e / p u h u / z a h i / &{return options.voi} v oi / &{return options.du} d u ) &post_word {return _word("NU", expr);}

NUhA = &cmavo expr:( n u h a ) &post_word {return _word("NUhA", expr);}

NUhI = &cmavo expr:( n u h i ) &post_word {return _word("NUhI", expr);}

NUhU = &cmavo expr:( n u h u ) &post_word {return _word("NUhU", expr);}

//// EXP-ADD: xo'e
PA = &cmavo expr:( x o h e / d au / f ei / g ai / j au / x ei / r ei / v ai / p i h e / p i / f i h u / z a h u / m e h i / n i h u / k i h o / c e h i / m a h u / r a h e / d a h a / s o h a / j i h i / &{return !options.su} s u h o / s u h e / r o / r au / s o h u / s o h i / s o h e / s o h o / m o h a / d u h e / t e h o / k a h o / c i h i / t u h o / x o / p ai / n o h o / n o / p a / r e / c i / v o / m u / x a / z e / b i / s o / &{return options.su} s u / digit ) &post_word {return _word("PA", expr);}

PEhE = &cmavo expr:( p e h e ) &post_word {return _word("PEhE", expr);}

PEhO = &cmavo expr:( p e h o ) &post_word {return _word("PEhO", expr);}

PU = &cmavo expr:( b i h ai / k a h ai / z e h u / z e h a / z e h i / z e h e / c o h i / p u h o / c o h u / m o h u / c a h o / c o h a / d e h a / b a h o / d i h a / z a h o / x a h o / v e h u / v e h a / v e h i / v e h e / v i h i / v i h a / v i h u / v i h e / r u h i / t a h e / d i h i / n a h o / d u h o / &{return !options.diftogoteha} s i h u / z au / k i h i / d u h i / c u h u / t u h i / t i h u / &{return !options.diftogoteha} d i h o / j i h u / r i h a / n i h i / m u h i / k i h u / v a h u / &{return !options.koi} k oi / c a h i / t a h i / p u h e / j a h i / k ai / b ai / f i h e / d e h i / c i h o / m au / m u h u / r i h i / r a h i / k a h a / p a h u / p a h a / l e h a / k u h u / t ai / b au / m a h i / c i h e / f au / p o h i / c au / m a h e / c i h u / r a h a / p u h a / l i h e / l a h u / b a h i / k a h i / s au / f a h e / b e h i / t i h i / j a h e / g a h a / v a h o / j i h o / m e h a / d o h e / j i h e / p i h o / g au / z u h e / m e h e / r ai / c a h a / p u h i / n u h o / k a h e / c u h e / n au / d u h a / b e h a / n e h u / v u h a / g a h u / t i h a / n i h a / c a h u / z u h a / r i h u / r u h u / r e h o / t e h e / &{return options.buhu != "bu"} b u h u / n e h a / p a h o / n e h i / t o h o / z o h i / z e h o / z o h a / f a h a / x au / &{return options.ckt} k e h a / &{return options.buhu == "zai"} z ai / &{return options.buhu == "bu"} b u / b a / p u / c a / &{return !options.ckt} k i / v i / v a / v u / z i / z a / z u ) &post_word {return _word("PU", expr);}

//// EXP-ADD: mu'ei
ROI = &cmavo expr:( r e h u / r oi / m u h ei ) &post_word {return _word("ROI", expr);}

SA = &cmavo expr:( s a ) &post_word {return _word("SA", expr);}

SE = &cmavo expr:( s e / t e / v e / x e / t o h ai / v o h ai / x o h ai / s u h ei / s u h ai ) &post_word {return _word("SE", expr);}

SEI = &cmavo expr:( s ei / t i h o / l e h au ) &post_word {return _word("SEI", expr);}

SEhU = &cmavo expr:( s e h u ) &post_word {return _word("SEhU", expr);}

SI = &cmavo expr:( s i / z e h ei ) &post_word {return _word("SI", expr);}

SOI = &cmavo expr:( s oi / x oi / f i h oi ) &post_word {return _word("SOI", expr);}

SU = &cmavo expr:( &{return options.su} s u h o / &{return !options.su} s u ) &post_word {return _word(options.su ? "SUhO" : "SU", expr);}

TEhU = &cmavo expr:( t e h u ) &post_word {return _word("TEhU", expr);}

TEI = &cmavo expr:( t ei ) &post_word {return _word("TEI", expr);}

TO = &cmavo expr:( t o h i / t o ) &post_word {return _word("TO", expr);}

TOI = &cmavo expr:( t oi ) &post_word {return _word("TOI", expr);}

TUhE = &cmavo expr:( t u h e ) &post_word {return _word("TUhE", expr);}

TUhU = &cmavo expr:( t u h u ) &post_word {return _word("TUhU", expr);}

//// EXP-ADD: ko'oi, si'au, o'ai, xe'e, xo'o
UI = &cmavo expr:( l i h oi / f u h au / a h ei / k o h oi / s i h au / o h ai / &{return options.diftogoteha} s i h u / x e h e / x o h o / i h a / i e / a h e / u h i / i h o / i h e / a h a / i a / o h i / o h e / e h e / oi / u o / e h i / u h o / au / u a / a h i / i h u / i i / u h a / u i / a h o / ai / a h u / i u / ei / o h o / e h a / u u / o h a / o h u / u h u / e h o / i o / e h u / u e / i h i / u h e / b a h a / j a h o / c a h e / s u h a / t i h e / k a h u / s e h o / z a h a / p e h i / r u h a / j u h a / t a h o / r a h u / l i h a / b a h u / m u h a / d o h a / t o h u / v a h i / p a h e / z u h u / s a h e / l a h a / k e h u / s a h u / d a h i / j e h u / s a h a / k au / t a h u / n a h i / j o h a / b i h u / l i h o / p au / m i h u / k u h i / j i h a / s i h a / p o h o / p e h a / r o h i / r o h e / r o h o / r o h u / r o h a / r e h e / l e h o / j u h o / f u h i / d ai / g a h i / z o h o / b e h u / r i h e / s e h i / s e h a / v u h e / k i h a / x u / g e h e / b u h o / d a h o / r a h o / b i h a / z i h a / &{return options.koi} k oi ) &post_word {return _word("UI", expr);}

VAU = &cmavo expr:( v au ) &post_word {return _word("VAU", expr);}

VEI = &cmavo expr:( v ei ) &post_word {return _word("VEI", expr);}

VEhO = &cmavo expr:( v e h o ) &post_word {return _word("VEhO", expr);}

VUhU = &cmavo expr:( g e h a / f u h u / p i h i / f e h i / v u h u / s u h i / j u h u / g ei / p a h i / f a h i / t e h a / c u h a / v a h a / n e h o / d e h o / f e h a / s a h o / r e h a / r i h o / s a h i / p i h a / s i h i ) &post_word {return _word("VUhU", expr);}

VUhO = &cmavo expr:( v u h o ) &post_word {return _word("VUhO", expr);}

XI = &cmavo expr:( x i / t e h ai ) &post_word {return _word("XI", expr);}

Y = &cmavo expr:( y+ ) &post_word {return _join(expr);}

ZEI = &cmavo expr:( z ei ) &post_word {return _word("ZEI", expr);}

//// EXP-ADD: ma'oi
ZO = &cmavo expr:( z o / m a h oi ) &post_word {return _word("ZO", expr);}

ZOI = &cmavo expr:( z oi / l a h o ) &post_word {return _word("ZOI", expr);}

//// EXP-ADD: ce'ai
ZOhU = &cmavo expr:( c e h ai / z o h u ) &post_word {return _word("ZOhU", expr);}

// ___ EXPERIMENTAL SELMAHO ___ //

ZOhOI = &cmavo expr:( z o h oi / l a h oi / r a h oi ) &post_word {return _word("ZOhOI", expr);}
MEhOI = &cmavo expr:( m e h oi ) &post_word {return _word("MEhOI", expr);}
GOhOI = &cmavo expr:( g o h oi ) &post_word {return _word("GOhOI", expr);}
NOhOI = &cmavo expr:( n o h oi / p o h oi ) &post_word {return _word("NOhOI", expr);}
KUhOI = &cmavo expr:( k u h oi ) &post_word {return _word("KUhOI", expr);}
LOhOI = &cmavo expr:( l o h oi / x u h u / &{return options.po} p o ) &post_word {return _word(options.po ? "PO" : "LOhOI", expr);}
KUhAU = &cmavo expr:( k u h au / &{return options.po} p o h e ) &post_word {return _word(options.po ? "POhE" : "KUhAU", expr);}
